var documenterSearchIndex = {"docs":
[{"location":"api/types/#Types-API","page":"Types","title":"Types API","text":"Documentation for core types and type system.","category":"section"},{"location":"api/types/#PhasorNetworks.Args","page":"Types","title":"PhasorNetworks.Args","text":"Args\n\nConfiguration parameters for training neural networks in the PhasorNetworks framework.\n\nFields\n\nlr::Float64: Learning rate for optimization (default: 0.0003). Kept as Float64 for Optimisers.jl compatibility\nbatchsize::Int: Number of samples per batch during training (default: 128)\nepochs::Int: Number of training epochs (default: 10)\nuse_cuda::Bool: Whether to use GPU acceleration if available (default: true)\nrng::Xoshiro: Random number generator for reproducibility (default: Xoshiro(42))\n\n\n\n\n\n","category":"type"},{"location":"api/types/#PhasorNetworks.CurrentCall","page":"Types","title":"PhasorNetworks.CurrentCall","text":"CurrentCall\n\nA complete specification for simulating neural dynamics with a current input. Combines a current source with simulation parameters and time span.\n\nFields\n\ncurrent::LocalCurrent: The current source to be applied\nspk_args::SpikingArgs: Simulation parameters\nt_span::Tuple{<:Real, <:Real}: Time interval for simulation (start, end)\n\nCan be created from a SpikingCall to transform spike-based input into continuous current. Used in oscillator bank simulations and neural network dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#PhasorNetworks.LocalCurrent","page":"Types","title":"PhasorNetworks.LocalCurrent","text":"LocalCurrent\n\nRepresents a spatially distributed current source in the neural network. Used to model current injection into neurons based on spike inputs.\n\nFields\n\ncurrent_fn::Function: Function that computes current at a given time\nshape::Tuple: Spatial dimensions of the current distribution\noffset::Float32: Time offset for the current function\n\nCan be created from SpikingTypes using SpikingArgs to define the current kernel. Used in oscillator bank simulations for neural dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#PhasorNetworks.SpikeTrain","page":"Types","title":"PhasorNetworks.SpikeTrain","text":"SpikeTrain{N}\n\nA data structure representing a sequence of spikes (neural impulses) in N-dimensional space. Used for modeling spiking neural networks and implementing Vector Symbolic Architectures (VSA).\n\nFields\n\nindices::Array{<:Union{Int, CartesianIndex},1}: Location of spikes in N-dimensional space\ntimes::Array{Float32,1}: Timing of each spike in seconds\nshape::Tuple: Dimensions of the spike space\noffset::Float32: Time offset of the spike train, used in synchronization\n\nType Parameter\n\nN: Number of dimensions in the spike space\n\nSee also: SpikeTrainGPU for GPU-accelerated version.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#PhasorNetworks.SpikeTrainGPU","page":"Types","title":"PhasorNetworks.SpikeTrainGPU","text":"SpikeTrainGPU{N}\n\nGPU-accelerated version of SpikeTrain, optimized for CUDA operations. Provides the same functionality as SpikeTrain but with additional fields for efficient GPU computation.\n\nFields\n\nindices::CuArray: GPU array of spike locations in N-dimensional space\nlinear_indices::CuArray: Linearized indices for efficient GPU memory access\ntimes::CuArray{<:Real}: GPU array of spike timings in seconds\nshape::Tuple: Dimensions of the spike space\nlinear_shape::Int: Total size of the flattened spike space\noffset::Float32: Time offset of the spike train\n\nType Parameter\n\nN: Number of dimensions in the spike space\n\nCan be converted to/from CPU SpikeTrain using Base.convert. See also: SpikeTrain\n\n\n\n\n\n","category":"type"},{"location":"api/types/#PhasorNetworks.SpikingArgs","page":"Types","title":"PhasorNetworks.SpikingArgs","text":"SpikingArgs\n\nConfiguration parameters for spiking neural network simulation. Controls neuron dynamics, spike generation, and numerical integration.\n\nFields\n\nleakage::Float32: Leakage term in neuron dynamics\nt_period::Float32: Time period of oscillation in seconds\nt_window::Float32: Time window for spike current kernel\nspk_scale::Float32: Scaling factor for spike currents\nthreshold::Float32: Voltage threshold for spike generation\nspike_kernel::Union{Symbol, Function}: Spike kernel function (e.g., :gaussian) or custom function\nsolver: ODE solver for neural dynamics (typically Heun())\nsolver_args::Dict: Arguments for the ODE solver\nupdate_fn::Function: Update function for neural state\n\nUsed in both simulation and training of spiking neural networks. See also: SpikingArgs_NN for neural network specific variant.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#PhasorNetworks.SpikingCall","page":"Types","title":"PhasorNetworks.SpikingCall","text":"SpikingCall\n\nA complete specification for running a spiking neural network simulation. Bundles a spike train with its simulation parameters and time span.\n\nFields\n\ntrain::SpikingTypes: The spike train (CPU or GPU) to be simulated\nspk_args::SpikingArgs: Simulation parameters\nt_span::Tuple{Float32, Float32}: Time interval for simulation (start, end)\n\nUsed in the neural network layers and VSA operations for consistent simulation settings. Created by MakeSpiking layer when converting phase data to spike representations.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#PhasorNetworks.SpikingArgs_NN-Tuple{}","page":"Types","title":"PhasorNetworks.SpikingArgs_NN","text":"SpikingArgs_NN(;\n    leakage::Real = -0.2f0,\n    t_period::Real = 1.0f0,\n    t_window::Real = 0.01f0,\n    spk_scale::Real = 1.0f0,\n    threshold::Real = 0.001f0,\n    spike_kernel = :gaussian,\n    solver = Heun(),\n    solver_args = Dict(...),\n    update_fn::Function)\n\nNeural network specific variant of spiking arguments configuration.\n\nArguments\n\nleakage: Neuron leakage rate (default: -0.2f0)\nt_period: Time period for oscillation (default: 1.0f0)\nt_window: Time window for spike integration (default: 0.01f0)\nspk_scale: Scaling factor for spikes (default: 1.0f0)\nthreshold: Spike threshold value (default: 0.001f0)\nspike_kernel: Type of spike kernel to use (default: :gaussian)\nsolver: ODE solver to use (default: Heun())\nsolver_args: Dictionary of solver arguments\nupdate_fn: Function for updating neuron state\n\nReturns\n\nSpikingArgs configuration object for neural networks\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#GPU-API","page":"GPU","title":"GPU API","text":"Documentation for GPU acceleration functionality.","category":"section"},{"location":"api/gpu/#PhasorNetworks.gaussian_kernel_gpu-Tuple{Float32, Float32, Float32}","page":"GPU","title":"PhasorNetworks.gaussian_kernel_gpu","text":"gaussian_kernel_gpu(x::Float32, t::Float32, t_sigma::Float32) -> Float32\n\nGPU-optimized version of the Gaussian kernel used in spike current calculations. All inputs are Float32 for CUDA compatibility.\n\nArguments\n\nx::Float32: Time of the spike\nt::Float32: Current time\nt_sigma::Float32: Width of the Gaussian kernel\n\nReturns the spike current value at time t for a spike at time x.\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.on_gpu-Tuple","page":"GPU","title":"PhasorNetworks.on_gpu","text":"on_gpu(args...) -> Bool\n\nCheck if any of the provided arguments are CUDA arrays.\n\nUsed to determine if computation should proceed on GPU or CPU path. Returns true if at least one argument is a CuArray.\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.oscillator_bank-Tuple{SpikeTrainGPU{3}, CUDA.CuArray, CUDA.CuArray}","page":"GPU","title":"PhasorNetworks.oscillator_bank","text":"oscillator_bank(x::SpikeTrainGPU{3}, w::CuArray, b::CuArray; tspan, spk_args) -> ODESolution\n\nGPU-optimized neural network layer simulation for 3D spike trains (batched 2D data). Implements the weighted connections and bias terms for network layers.\n\nArguments\n\nx::SpikeTrainGPU{3}: Input spike train with shape (features, spatial_dim, batch)\nw::CuArray: Weight matrix\nb::CuArray: Bias terms\ntspan: Time span for simulation\nspk_args::SpikingArgs: Neuron parameters\n\nImplementation\n\nSolves the neural ODE: dz/dt = updatefn(z) + W * spikecurrent(x, t) + bias_current(b, t)\n\nReturns an ODESolution object containing the network dynamics.\n\nSee also: Other oscillator_bank methods for different dimensionalities\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.oscillator_bank-Tuple{SpikeTrainGPU}","page":"GPU","title":"PhasorNetworks.oscillator_bank","text":"oscillator_bank(x::SpikeTrainGPU; tspan=(0.0f0, 10.0f0), spk_args::SpikingArgs) -> ODESolution\n\nGPU implementation of oscillator bank simulation for spiking neural networks. Simulates the dynamics of a bank of oscillators driven by spike inputs.\n\nArguments\n\nx::SpikeTrainGPU: Input spike train on GPU\ntspan::Tuple{<:Real, <:Real}: Time span for simulation\nspk_args::SpikingArgs: Parameters for neuron dynamics\n\nImplementation\n\nSets up and solves the ODE system: dz/dt = updatefn(z) + spikecurrent(x, t) where z is the complex potential of each neuron.\n\nSee also: oscillator_bank in spiking.jl for CPU version\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.parallel_scatter_add!-Tuple{CUDA.CuArray, CUDA.CuArray{Int64}, CUDA.CuArray}","page":"GPU","title":"PhasorNetworks.parallel_scatter_add!","text":"parallel_scatter_add!(output::CuArray, indices::CuArray{Int}, values::CuArray)\n\nIn-place version of parallelscatteradd that reuses a pre-allocated output buffer. The output array must be pre-zeroed before calling this function.\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.parallel_scatter_add-Union{Tuple{T}, Tuple{CUDA.CuArray{Int64}, CUDA.CuArray{T}, Int64}} where T","page":"GPU","title":"PhasorNetworks.parallel_scatter_add","text":"parallel_scatter_add(indices::CuArray{Int}, values::CuArray{T}, output_size::Int) where T -> CuArray{T}\n\nPerform parallel scatter-add operation on GPU using atomic operations. Used for efficiently accumulating spike currents in the network.\n\nArguments\n\nindices::CuArray{Int}: Target indices for the values\nvalues::CuArray{T}: Values to be scattered and added\noutput_size::Int: Size of the output array\n\nImplementation\n\nUses CUDA atomic operations to safely accumulate values in parallel. Each thread processes one (index, value) pair and atomically adds to the corresponding location in the output array.\n\nReturns a CuArray of size output_size containing the accumulated values.\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.potential_to_phase-Tuple{CUDA.CuArray, AbstractVector}","page":"GPU","title":"PhasorNetworks.potential_to_phase","text":"potential_to_phase(potential::CuArray, ts::AbstractVector; spk_args::SpikingArgs, offset::Real=0.0f0, threshold::Bool=false) -> CuArray\n\nGPU implementation of potential to phase conversion for neural states. Extends the CPU version in domains.jl with CUDA-optimized array operations.\n\nArguments\n\npotential::CuArray: Complex-valued neural potentials on GPU\nts::AbstractVector: Time points corresponding to potential values\nspk_args::SpikingArgs: Spiking neuron parameters\noffset::Real=0.0f0: Time offset for phase calculation\nthreshold::Bool=false: Whether to apply threshold checks\n\nImplementation\n\nComputes reference zero-phase potentials\nCalculates phase differences using complex angles\nNormalizes to [-1, 1] range\nMarks sub-threshold neurons with NaN\n\nSee also: potential_to_phase for CPU version\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.similarity_outer-Tuple{CUDA.CuArray{ComplexF32, 3}, CUDA.CuArray{ComplexF32, 3}}","page":"GPU","title":"PhasorNetworks.similarity_outer","text":"similarity_outer(A::CuArray{ComplexF32,3}, B::CuArray{ComplexF32,3}; dims=2) -> CuArray{Float32,3}\n\nGPU-optimized pairwise similarity computation between sets of complex-valued vectors. Provides a vectorized implementation that is efficient on GPUs and compatible with automatic differentiation.\n\nArguments\n\nA::CuArray{ComplexF32,3}: First set of vectors\nB::CuArray{ComplexF32,3}: Second set of vectors\ndims::Int=2: Dimension along which to slice vectors for pairwise comparison\n\nFor dims=2 with shape (features, n_vectors, batch):\n\nReturns shape (n_vectors_A, n_vectors_B, batch) matching CPU implementation\n\nImplementation Details\n\nUses broadcasting for vectorized operations\nAvoids custom CUDA kernels for AD compatibility (e.g., with Zygote)\nOptimizes similarity calculation using trigonometric identities\n\nSee also: similarity_outer in vsa.jl for CPU version\n\n\n\n\n\n","category":"method"},{"location":"api/gpu/#PhasorNetworks.spike_current!-Tuple{CUDA.CuArray{Float32}, SpikeTrainGPU, Float32, SpikingArgs, CUDA.CuArray{Float32}, CUDA.CuArray{Float32}}","page":"GPU","title":"PhasorNetworks.spike_current!","text":"spike_current!(output::CuArray, train::SpikeTrainGPU, t::Float32, spk_args::SpikingArgs,\n               currents_buffer::CuArray, scatter_buffer::CuArray)\n\nIn-place version of spikecurrent that reuses pre-allocated buffers to avoid GPU memory allocations during ODE integration. This is critical for performance when spikecurrent is called many times per simulation.\n\nArguments\n\noutput::CuArray: Pre-allocated output array with shape matching train.shape\ntrain::SpikeTrainGPU: Input spike train\nt::Float32: Current time\nspk_args::SpikingArgs: Spiking neuron parameters\ncurrents_buffer::CuArray: Pre-allocated buffer for kernel values (size = n_spikes)\nscatter_buffer::CuArray: Pre-allocated buffer for scatter-add (size = linear_shape)\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#Metrics-API","page":"Metrics","title":"Metrics API","text":"Documentation for metrics and evaluation functions.","category":"section"},{"location":"api/metrics/#PhasorNetworks.OvR_matrices-Tuple{Any, Any, Real}","page":"Metrics","title":"PhasorNetworks.OvR_matrices","text":"OvR_matrices(predictions, labels, threshold::Real)\n\nCompute One-vs-Rest confusion matrices for multi-class classification.\n\nArguments\n\npredictions: Array of model predictions, with classes along first dimension\nlabels: Array of true labels in one-hot format\nthreshold: Classification threshold value\n\nReturns\n\nArray of confusion matrices, one for each class vs rest\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.angular_mean-Tuple{AbstractArray}","page":"Metrics","title":"PhasorNetworks.angular_mean","text":"angular_mean(phases::AbstractArray; dims) -> AbstractArray\n\nCompute the circular mean of phase values along specified dimensions. Handles the circular nature of phases by converting to complex exponentials.\n\nArguments\n\nphases: Array of phase values in [-1, 1] range\ndims: Dimensions along which to compute mean\n\nImplementation\n\nConverts phases to complex exponentials (e^(iπθ))\nComputes arithmetic mean in complex plane\nConverts back to phase via angle\n\nReturns\n\nPhase values representing the circular mean along specified dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.arc_error-Tuple{Real}","page":"Metrics","title":"PhasorNetworks.arc_error","text":"arc_error(phase::Real) -> Real\narc_error(phases::AbstractArray) -> AbstractArray\n\nCompute the arc error for phase values, mapping phase differences to sinusoidal error. This provides a continuous, differentiable metric for phase differences.\n\nArguments\n\nphase: Phase value in [-1, 1] range\nphases: Array of phase values\n\nReturns\n\nSine of the phase multiplied by π, producing smooth error measure in [-1, 1].\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.confusion_matrix-Tuple{Any, Any, Real}","page":"Metrics","title":"PhasorNetworks.confusion_matrix","text":"confusion_matrix(sim, truth, threshold::Real) -> Matrix{<:Real}\n\nCompute binary confusion matrix given similarity scores and true labels.\n\nArguments\n\nsim: Similarity or prediction scores\ntruth: True labels (binary)\nthreshold: Decision threshold for converting scores to predictions\n\nReturns\n\n2×2 confusion matrix with format: [True Positive  False Positive] [False Negative True Negative]\n\nUsed by OvR_matrices for multi-class evaluation\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.cor_realvals-Tuple{Any, Any}","page":"Metrics","title":"PhasorNetworks.cor_realvals","text":"cor_realvals(x, y) -> Real\n\nCompute correlation between two arrays, handling NaN values appropriately. Only considers positions where both arrays have real (non-NaN) values.\n\nArguments\n\nx, y: Arrays of same size, potentially containing NaN values\n\nReturns\n\nCorrelation coefficient between non-NaN values\nReturns 0.0 if no valid pairs of values exist\n\nUsed by cycle_correlation and similarity_correlation\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.cycle_correlation-Tuple{AbstractMatrix{<:Real}, AbstractArray{<:Real, 3}}","page":"Metrics","title":"PhasorNetworks.cycle_correlation","text":"cycle_correlation(static_phases::Matrix{<:Real}, dynamic_phases::Array{<:Real,3}) -> Vector{<:Real}\n\nCompute correlation between static phase pattern and each cycle of dynamic phases.\n\nArguments\n\nstatic_phases: Reference phase matrix (2D)\ndynamic_phases: Time-varying phase matrices (3D array with cycles as third dimension)\n\nReturns\n\nVector of correlation values, one for each cycle\n\nSee also: cor_realvals for handling NaN values in correlation\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.cycle_sparsity-Tuple{Matrix{<:Real}, Array{<:Real, 3}}","page":"Metrics","title":"PhasorNetworks.cycle_sparsity","text":"cycle_sparsity(static_phases::Matrix{<:Real}, dynamic_phases::Array{<:Real,3}) -> Vector{<:Real}\n\nCalculate the sparsity (proportion of NaN values) for each cycle of dynamic phases.\n\nArguments\n\nstatic_phases: Reference phase matrix (2D), used for size reference\ndynamic_phases: Time-varying phase matrices (3D array with cycles as third dimension)\n\nReturns\n\nVector of sparsity values (0.0-1.0) for each cycle, where:\n\n0.0 indicates no NaN values\n1.0 indicates all values are NaN\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.dense_onehot-Tuple{OneHotArrays.OneHotMatrix}","page":"Metrics","title":"PhasorNetworks.dense_onehot","text":"dense_onehot(x::OneHotMatrix) -> Matrix{Float32}\n\nConvert a OneHotMatrix to a dense Float32 matrix. Useful for compatibility with neural network operations.\n\nArguments\n\nx: OneHotMatrix representation\n\nReturns\n\nDense matrix with 1.0f0 values where x was true\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.evaluate_accuracy-Tuple{AbstractArray, AbstractArray, Symbol}","page":"Metrics","title":"PhasorNetworks.evaluate_accuracy","text":"evaluate_accuracy(values::AbstractArray, truth::AbstractArray, encoding::Symbol; reduce_dim::Int=1) -> Tuple{Union{Int,Array},Int}\nevaluate_accuracy(values::SpikingCall, truth::AbstractArray, encoding::Symbol; reduce_dim::Int=1) -> Tuple{Union{Int,Array},Int}\n\nEvaluate classification accuracy for phase-based or spiking neural networks.\n\nArguments\n\nvalues: Model predictions (phases, similarities, or spike trains)\ntruth: Ground truth labels in one-hot format\nencoding: Encoding scheme (:similarity or :quadrature)\nreduce_dim: Dimension along which to compute accuracy (default: 1)\n\nImplementation\n\nMoves data to CPU if on GPU\nFinds indices of true classes from one-hot truth\nConverts predictions to class indices using specified encoding\nCounts correct predictions\nFor spike trains, first converts to phases\n\nReturns\n\nTuple of (correctpredictions, totalsamples) where:\n\ncorrect_predictions: Number of correct predictions (or array for multiple evaluations)\ntotal_samples: Total number of samples evaluated\n\nNotes\n\nHandles both direct predictions and spike train inputs\nSupports different dimensionality between predictions and truth\nAutomatically handles GPU/CPU device placement\n\nSee also: predict for the underlying prediction mechanism\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.evaluate_loss","page":"Metrics","title":"PhasorNetworks.evaluate_loss","text":"evaluate_loss(predictions::AbstractArray, truth::AbstractArray, encoding::Symbol = :similarity; reduce_dim::Int = 1) -> AbstractArray\nevaluate_loss(predictions::SpikingCall, truth::AbstractArray, encoding::Symbol = :similarity; reduce_dim::Int = 1) -> AbstractArray\n\nEvaluate loss between predictions and truth values using specified encoding scheme.\n\nArguments\n\npredictions: Model predictions (phases or spike trains)\ntruth: Target values\nencoding: Encoding scheme (:similarity or :quadrature)\nreduce_dim: Dimension along which to compute loss (default: 1)\n\nEncoding Schemes\n\n:similarity: Uses similarity_loss\n:quadrature: Uses quadrature_loss\n\nImplementation\n\nSelects appropriate loss function based on encoding\nHandles dimension mismatches between predictions and truth\nFor spike trains, converts to phases before evaluation\n\nReturns loss values appropriate for the chosen encoding scheme.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/#PhasorNetworks.exp_score-Tuple{AbstractArray}","page":"Metrics","title":"PhasorNetworks.exp_score","text":"exp_score(similarity::AbstractArray; scale::Real = 3.0f0) -> AbstractArray\n\nConvert similarity values to exponential scores, emphasizing differences. Useful for converting similarity metrics to loss-like values.\n\nArguments\n\nsimilarity: Array of similarity values in [0, 1] range\nscale: Scaling factor for exponential transformation (default: 3.0)\n\nReturns\n\nTransformed scores where:\n\nPerfect similarity (1.0) maps to 0.0\nLower similarities produce exponentially larger positive values\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.interpolate_roc-Tuple{Any}","page":"Metrics","title":"PhasorNetworks.interpolate_roc","text":"interpolate_roc(roc) -> Function\n\nCreate an interpolated function from ROC curve points. Useful for smooth ROC curve visualization and AUC calculation.\n\nArguments\n\nroc: Tuple of (TPR, FPR) vectors from tpr_fpr\n\nReturns\n\nInterpolation function mapping FPR to TPR values\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.loss_and_accuracy-NTuple{5, Any}","page":"Metrics","title":"PhasorNetworks.loss_and_accuracy","text":"loss_and_accuracy(data_loader, model, ps, st, args; reduce_dim::Int=1, encoding::Symbol = :codebook) -> Tuple{Real,Real}\n\nEvaluate model loss and accuracy on a dataset.\n\nArguments\n\ndata_loader: Iterator providing (input, target) pairs\nmodel: Neural network model\nps: Model parameters\nst: Model state\nargs: Configuration arguments (including use_cuda)\nreduce_dim: Dimension for reduction operations\nencoding: Phase encoding scheme (:codebook or :quadrature)\n\nReturns\n\nTuple of (average_loss, accuracy)\n\nNotes\n\nAutomatically handles GPU/CPU device placement based on args.use_cuda\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.predict","page":"Metrics","title":"PhasorNetworks.predict","text":"predict(predictions::AbstractArray, encoding::Symbol = :similarity; reduce_dim=1) -> AbstractArray\npredict(predictions::SpikingCall, encoding::Symbol = :similarity; reduce_dim::Int=1) -> AbstractArray\n\nConvert model outputs to class predictions using specified encoding scheme.\n\nArguments\n\npredictions: Model outputs (phases, similarities, or spike trains)\nencoding: Encoding scheme (:similarity or :quadrature)\nreduce_dim: Dimension along which to make predictions\n\nEncoding Schemes\n\n:similarity: Uses predict_similarity\n:quadrature: Uses predict_quadrature\n\nFor spike trains, automatically converts to phases before prediction.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/#PhasorNetworks.predict_quadrature-Tuple{AbstractArray}","page":"Metrics","title":"PhasorNetworks.predict_quadrature","text":"predict_quadrature(phases::AbstractArray; dim::Int=1) -> AbstractArray\n\nConvert phase values to class predictions using quadrature encoding. Finds classes by minimum distance to target phase (0.5).\n\nArguments\n\nphases: Array of phase values\ndim: Dimension along which to find predictions (default: 1)\n\nImplementation\n\nAutomatically handles GPU arrays by moving to CPU for argmin operation.\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.predict_similarity-Tuple{AbstractArray}","page":"Metrics","title":"PhasorNetworks.predict_similarity","text":"predict_similarity(sims::AbstractArray; dim::Int=1) -> AbstractArray\n\nConvert similarity values to class predictions by taking argmax. Used for similarity-based classification.\n\nArguments\n\nsims: Array of similarity values\ndim: Dimension along which to find maximum (default: 1)\n\nImplementation\n\nAutomatically handles GPU arrays by moving to CPU for argmax operation.\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.quadrature_loss-Tuple{AbstractArray, AbstractArray}","page":"Metrics","title":"PhasorNetworks.quadrature_loss","text":"quadrature_loss(phases::AbstractArray, truth::AbstractArray; dim::Int = 1) -> AbstractArray\n\nCompute loss based on quadrature phase encoding relative to target values.\n\nArguments\n\nphases: Array of phase values\ntruth: Target values (binary/one-hot encoded)\ndim: Dimension along which to compute similarity (default: 1)\n\nImplementation\n\nScales truth values to target phases (0.5 * truth)\nComputes similarity between phases and targets\nReturns dissimilarity (1 - similarity)\n\nUsed for phase-based classification tasks.\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.similarity_correlation-Tuple{AbstractMatrix{<:Real}, AbstractArray{<:Real, 3}}","page":"Metrics","title":"PhasorNetworks.similarity_correlation","text":"similarity_correlation(static_similarity::Matrix{<:Real}, dynamic_similarity::Array{<:Real,3}) -> Vector{<:Real}\n\nCompute correlation between static similarity matrix and each time step of dynamic similarities.\n\nArguments\n\nstatic_similarity: Reference similarity matrix (2D)\ndynamic_similarity: Time-varying similarity matrices (3D array with time as third dimension)\n\nReturns\n\nVector of correlation values, one for each time step\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.similarity_loss-Tuple{AbstractArray, AbstractArray}","page":"Metrics","title":"PhasorNetworks.similarity_loss","text":"similarity_loss(similarities::AbstractArray, truth::AbstractArray; dim::Int = 1) -> AbstractArray\n\nCompute a smooth loss function based on phase similarities and truth values.\n\nArguments\n\nsimilarities: Array of similarity values\ntruth: Target values (binary/one-hot encoded)\ndim: Dimension along which to compute loss (default: 1)\n\nImplementation\n\nComputes absolute difference from perfect similarity (1.0)\nWeights differences by truth values\nApplies smooth sin² transformation for stable gradients\n\nReturns a loss that:\n\nIs 0 for perfect similarity with correct class\nGrows smoothly for increasing dissimilarity\nIs properly scaled for gradient-based optimization\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.spiking_loss_and_accuracy-NTuple{5, Any}","page":"Metrics","title":"PhasorNetworks.spiking_loss_and_accuracy","text":"spiking_loss_and_accuracy(data_loader, model, ps, st, args; reduce_dim::Int=1, encoding::Symbol = :codebook, repeats::Int) -> Tuple{Array,Array}\n\nEvaluate spiking neural network loss and accuracy over multiple repeats.\n\nArguments\n\ndata_loader: Iterator providing (input, target) pairs\nmodel: Spiking neural network model\nps: Model parameters\nst: Model state\nargs: Configuration arguments\nreduce_dim: Dimension for reduction operations\nencoding: Phase encoding scheme\nrepeats: Number of evaluation repeats\n\nReturns\n\nTuple of (losses, accuracies) where:\n\nlosses: Array of shape (1, repeats)\naccuracies: Array of length repeats\n\nUseful for assessing the reliability of spiking network performance.\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#PhasorNetworks.tpr_fpr","page":"Metrics","title":"PhasorNetworks.tpr_fpr","text":"tpr_fpr(prediction, labels, points::Int = 201, epsilon::Real = 0.01f0)\n\nCalculate True Positive Rate (TPR) and False Positive Rate (FPR) curves for ROC analysis.\n\nArguments\n\nprediction: Model predictions array\nlabels: True labels array\npoints: Number of threshold points to evaluate (default: 201)\nepsilon: Small value to prevent division by zero (default: 0.01f0)\n\nReturns\n\nTuple of (TPR, FPR) arrays for ROC curve plotting\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/#PhasorNetworks.z_score-Tuple{AbstractArray}","page":"Metrics","title":"PhasorNetworks.z_score","text":"z_score(phases::AbstractArray) -> AbstractArray\n\nCompute a z-score like metric for phase values using inverse hyperbolic tangent. Provides a measure of how far phases deviate from the midpoint (0.5).\n\nArguments\n\nphases: Array of phase values in [-1, 1] range\n\nImplementation\n\nCenters phases around 0 by subtracting 0.5\nRemaps to standard phase range\nApplies inverse hyperbolic tangent and takes absolute value\n\nReturns\n\nNon-negative scores that grow larger for phases further from 0.5\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#VSA-API","page":"VSA","title":"VSA API","text":"Documentation for Vector Symbolic Architecture operations.","category":"section"},{"location":"api/vsa/#PhasorNetworks.chance_level-Tuple{Int64, Int64}","page":"VSA","title":"PhasorNetworks.chance_level","text":"chance_level(nd::Int, samples::Int) -> Float32\n\nCalculate the expected standard deviation of similarities between random VSA symbols. This function helps in determining the statistical significance of similarity measurements.\n\nArguments\n\nnd::Int: Number of dimensions for the VSA symbols\nsamples::Int: Number of random samples to generate\n\nReturns the standard deviation of similarities between random symbols, which represents the expected variation in similarity scores due to chance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.interference_similarity-Tuple{AbstractArray}","page":"VSA","title":"PhasorNetworks.interference_similarity","text":"interference_similarity(interference::AbstractArray; dim::Int=-1) -> AbstractArray\n\nCalculate similarity from interference patterns between complex-valued VSA representations. This function converts interference magnitudes to similarity scores using geometric relationships.\n\nArguments\n\ninterference::AbstractArray: Array of interference magnitudes (typically |u₁ + u₂|)\ndim::Int: Dimension along which to average (default: -1 for last dimension)\n\nDetails\n\nClamps interference magnitudes to [0, 2]\nConverts to half-angles using arccos\nComputes similarity using cosine of double angle\nAverages along specified dimension\n\nReturns similarity scores in [-1, 1] range, averaged over the specified dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.random_symbols-Tuple{Tuple{Vararg{Int64}}}","page":"VSA","title":"PhasorNetworks.random_symbols","text":"random_symbols(size::Tuple{Vararg{Int}}) -> Array{Float32}\nrandom_symbols(rng::AbstractRNG, size::Tuple{Vararg{Int}}) -> Array{Float32}\n\nGenerate random VSA symbols with values uniformly distributed in [-1, 1]. These symbols serve as base vectors for VSA operations.\n\nArguments\n\nsize::Tuple{Vararg{Int}}: Dimensions of the output array\nrng::AbstractRNG: Optional random number generator for reproducibility\n\nReturns an array of random phases suitable for VSA operations.\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.remap_phase-Tuple{Real}","page":"VSA","title":"PhasorNetworks.remap_phase","text":"remap_phase(x::Real) -> Float32\nremap_phase(x::AbstractArray) -> AbstractArray\n\nRemap phase values to the interval [-1, 1] using modular arithmetic. This function maintains the cyclic nature of phases while keeping them in a consistent range.\n\nArguments\n\nx: Phase value(s) to remap\n\nThe operation is performed within ignore_derivatives to avoid tracking through the modulo operation in automatic differentiation.\n\nReturns phase values normalized to [-1, 1].\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.similarity-Tuple{AbstractArray, AbstractArray}","page":"VSA","title":"PhasorNetworks.similarity","text":"similarity(x::AbstractArray, y::AbstractArray; dim::Int = 1) -> AbstractArray\n\nCompute the similarity between two arrays of phase values using cosine distance. The similarity is calculated by taking the cosine of the phase difference and averaging.\n\nArguments\n\nx::AbstractArray: First array of phase values\ny::AbstractArray: Second array of phase values\ndim::Int: Dimension along which to compute similarity (default: 1, use -1 for last dimension)\n\nReturns similarity scores in [-1, 1], where:\n\n1 indicates identical phases\n0 indicates orthogonal phases\n-1 indicates opposite phases\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.similarity_outer-Tuple{AbstractArray{<:Real, 3}, AbstractArray{<:Real, 3}}","page":"VSA","title":"PhasorNetworks.similarity_outer","text":"similarity_outer(x::AbstractArray, y::AbstractArray; dims=2) -> AbstractArray\n\nCompute pairwise similarities between slices of two arrays, supporting both real-valued phases and complex-valued representations.\n\nArguments\n\nx::AbstractArray: First array of values\ny::AbstractArray: Second array of values\ndims::Int: Dimension along which to slice the arrays (default: 2)\n\nMethods\n\nFor real-valued 3D arrays: Returns similarities with shape (N₁, N₂, B) where N₁,N₂ are slice dimensions and B is batch\nFor real-valued 2D arrays: Returns similarities with shape (N₁, N₂) where N₁,N₂ are slice dimensions\nFor complex-valued arrays: Uses interference-based similarity with shape (N₁, N₂, B)\n\nReturns a similarity matrix reshaped to maintain batch dimension as the last dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.v_bind-Tuple{AbstractArray}","page":"VSA","title":"PhasorNetworks.v_bind","text":"v_bind(x::AbstractArray; dims) -> AbstractArray\n\nBind vectors in a Vector Symbolic Architecture (VSA) by summing phases along specified dimensions. This operation preserves the structure while combining information from multiple vectors.\n\nArguments\n\nx::AbstractArray: Input array of phase values\ndims: Dimensions along which to perform binding\n\nReturns the bound phase values remapped to [-1, 1].\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.v_bundle-Tuple{AbstractArray}","page":"VSA","title":"PhasorNetworks.v_bundle","text":"v_bundle(x::AbstractArray; dims::Int) -> AbstractArray\n\nBundle vectors in VSA representation by converting phases to complex numbers, summing along specified dimensions, and converting back to phase angles. This operation is used to create superpositions of multiple vectors.\n\nArguments\n\nx::AbstractArray: Input array of phase values\ndims::Int: Dimension along which to perform bundling\n\nReturns bundled phases representing the superposition of input vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.v_bundle_project-Tuple{AbstractArray, AbstractMatrix, AbstractVecOrMat}","page":"VSA","title":"PhasorNetworks.v_bundle_project","text":"v_bundle_project(x::AbstractArray, w::AbstractMatrix, b::AbstractVecOrMat) -> AbstractArray\n\nProject bundled vectors through a linear transformation followed by a soft angle conversion. Used in neural network layers to transform VSA representations while maintaining phase-based encoding.\n\nArguments\n\nx::AbstractArray: Input array of phase values\nw::AbstractMatrix: Weight matrix for linear transformation\nb::AbstractVecOrMat: Bias term\n\nReturns transformed phases using a soft angle conversion for stable gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/vsa/#PhasorNetworks.v_unbind-Tuple{AbstractArray, AbstractArray}","page":"VSA","title":"PhasorNetworks.v_unbind","text":"v_unbind(x::AbstractArray, y::AbstractArray) -> AbstractArray\nv_unbind(x::SpikingTypes, y::SpikingTypes; kwargs...) -> SpikingTypes\n\nUnbind two VSA vectors by subtracting their phases (inverse of binding). This operation is used to recover bound components.\n\nArguments\n\nFor arrays:\nx::AbstractArray: First array of phase values\ny::AbstractArray: Second array of phase values\nFor spiking types:\nx::SpikingTypes: First spike train\ny::SpikingTypes: Second spike train\nkwargs...: Additional arguments passed to v_bind\n\nThe array method performs phase subtraction with remapping to [-1, 1]. The spiking method uses v_bind with unbind=true for consistent handling.\n\nReturns unbound phases or spike train.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#Domains-API","page":"Domains","title":"Domains API","text":"Documentation for domain transformation functions.","category":"section"},{"location":"api/domains/#PhasorNetworks.angfreq_to_period-Tuple{Real}","page":"Domains","title":"PhasorNetworks.angfreq_to_period","text":"angfreq_to_period(angfreq::Real)\n\nConvert an angular frequency to time period.\n\nArguments\n\nangfreq::Real: Angular frequency (ω) in radians per unit time\n\nReturns\n\nTime period (τ = 2π/ω)\n\nDetails\n\nThis function is auto-inverting due to the reciprocal relationship between period and angular frequency. The implementation uses periodtoangfreq since τ = 2π/ω = 2π/(2π/τ₀) = τ₀.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.angle_to_complex-Tuple{AbstractArray}","page":"Domains","title":"PhasorNetworks.angle_to_complex","text":"angle_to_complex(x::AbstractArray)\n\nConvert an array of angles (in units of π radians) to complex numbers on the unit circle. Each angle θ is mapped to exp(iπθ), resulting in complex numbers with unit magnitude.\n\nArguments\n\nx::AbstractArray: Array of angles in units of π radians\n\nReturns\n\nComplex array where each element is exp(iπθ) for the corresponding angle θ\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.cmpx_to_realvec-Tuple{Array{<:Complex}}","page":"Domains","title":"PhasorNetworks.cmpx_to_realvec","text":"cmpx_to_realvec(u::Array{<:Complex})\n\nConvert an array of complex numbers to a real-valued array by stacking real and imaginary parts. The output array has an additional first dimension of size 2, containing real parts in index 1 and imaginary parts in index 2.\n\nArguments\n\nu::Array{<:Complex}: Input array of complex numbers\n\nReturns\n\nArray of real numbers with shape (2, size(u)...)\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.complex_to_angle-Tuple{AbstractArray}","page":"Domains","title":"PhasorNetworks.complex_to_angle","text":"complex_to_angle(x::AbstractArray)\n\nConvert an array of complex numbers to their angles in units of π radians.\n\nArguments\n\nx::AbstractArray: Array of complex numbers\n\nReturns\n\nArray of angles in units of π radians, in range [-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.complex_to_angle-Tuple{Real, Real}","page":"Domains","title":"PhasorNetworks.complex_to_angle","text":"complex_to_angle(x_real::Real, x_imag::Real)\n\nConvert real and imaginary components to an angle in units of π radians.\n\nArguments\n\nx_real::Real: Real component of complex number\nx_imag::Real: Imaginary component of complex number\n\nReturns\n\nAngle in units of π radians, in range [-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.gaussian_kernel-Tuple{AbstractArray, Real, Real}","page":"Domains","title":"PhasorNetworks.gaussian_kernel","text":"gaussian_kernel(x::AbstractArray, t::Real, t_sigma::Real) -> Array{Float32}\ngaussian_kernel_vec(x::AbstractVector, ts::Vector, t_sigma::Real) -> Array{Float32}\narc_gaussian_kernel(x::AbstractVecOrMat, t::Real, t_sigma::Real) -> Array{Float32}\n\nFamily of kernel functions for computing spike-induced currents.\n\nArguments\n\nx: Spike times or phase values\nt: Current time (or vector of times for _vec variant)\nt_sigma: Width parameter of the kernel\n\nVariants\n\ngaussian_kernel: Standard Gaussian kernel for spike times\ngaussian_kernel_vec: Vectorized version for multiple evaluation times\narc_gaussian_kernel: Circular/periodic version using sine distance\n\nSee also: gaussian_kernel_gpu for GPU implementation\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.neuron_constant-Tuple{Real, Real}","page":"Domains","title":"PhasorNetworks.neuron_constant","text":"neuron_constant(leakage::Real, t_period::Real)\n\nCalculate the complex frequency constant for a Resonate-and-Fire neuron.\n\nArguments\n\nleakage::Real: Leakage/damping rate of the neuron\nt_period::Real: Oscillation period\n\nReturns\n\nComplex frequency constant k = λ + iω, where:\nλ is the leakage rate\nω is the angular frequency (2π/period)\n\nDetails\n\nThis complex constant determines both the frequency of oscillation and the rate of decay in the neuron's dynamics. The real part (leakage) controls damping, while the imaginary part sets the oscillation frequency.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.neuron_constant-Tuple{SpikingArgs}","page":"Domains","title":"PhasorNetworks.neuron_constant","text":"neuron_constant(spk_args::SpikingArgs)\n\nConvenience function to calculate the neuron's complex frequency constant from SpikingArgs.\n\nArguments\n\nspk_args::SpikingArgs: Spiking neuron parameters containing leakage and period\n\nReturns\n\nComplex frequency constant k = λ + iω using parameters from spk_args\n\nDetails\n\nThis is a wrapper around neuronconstant(leakage, tperiod) that extracts the parameters from a SpikingArgs struct.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.period_to_angfreq-Tuple{Real}","page":"Domains","title":"PhasorNetworks.period_to_angfreq","text":"period_to_angfreq(t_period::Real)\n\nConvert a time period to angular frequency.\n\nArguments\n\nt_period::Real: Time period (τ)\n\nReturns\n\nAngular frequency (ω = 2π/τ) in radians per unit time\n\nDetails\n\nImplements the standard relationship between period and angular frequency: ω = 2π/τ where τ is the period and ω is the angular frequency.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.phase_to_current-Tuple{AbstractArray}","page":"Domains","title":"PhasorNetworks.phase_to_current","text":"phase_to_current(phases::AbstractArray; spk_args::SpikingArgs, offset::Real = 0.0f0, \n                tspan::Tuple{<:Real, <:Real}, rng::Union{AbstractRNG, Nothing} = nothing, \n                zeta::Real=Float32(0.0))\n\nConvert a set of phases to a time-varying current function using a Gaussian kernel. The current at each time point is computed based on the phase difference between the input phases and the current time, with optional noise.\n\nArguments\n\nphases::AbstractArray: Array of phases in range [-1, 1]\nspk_args::SpikingArgs: Spiking neuron parameters\noffset::Real = 0.0f0: Time offset for phase calculations\ntspan::Tuple{<:Real, <:Real}: Time span over which the current will be defined\nrng::Union{AbstractRNG, Nothing} = nothing: Random number generator for noise\nzeta::Real=Float32(0.0): Noise amplitude (0 for no noise)\n\nReturns\n\nCurrentCall: Object containing a LocalCurrent function that computes the current at any given time point, along with the spiking parameters and time span\n\nDetails\n\nThe current is computed using a Gaussian kernel centered at each phase, with width determined by spkargs.twindow. Optional Gaussian noise can be added with amplitude zeta. The returned function preserves the input array's shape and can be evaluated at any time within the specified time span.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.phase_to_potential-Tuple{AbstractArray, AbstractVector}","page":"Domains","title":"PhasorNetworks.phase_to_potential","text":"phase_to_potential(phase::AbstractArray, ts::AbstractVector; offset::Real=0.0f0, spk_args::SpikingArgs)\n\nConvert an array of phases to a matrix of complex potentials, computing the potential for each phase at each specified time point.\n\nArguments\n\nphase::AbstractArray: Array of phase values in range [-1, 1]\nts::AbstractVector: Vector of time points\noffset::Real=0.0f0: Time offset for phase calculations\nspk_args::SpikingArgs: Spiking neuron parameters\n\nReturns\n\nMatrix of complex potentials with size (length(phase), length(ts))\n\nDetails\n\nCreates a matrix where each row corresponds to a phase value and each column corresponds to a time point, containing the complex potential of an R&F neuron with that phase at that time.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.phase_to_potential-Tuple{Real, AbstractVector}","page":"Domains","title":"PhasorNetworks.phase_to_potential","text":"phase_to_potential(phase::Real, ts::AbstractVector; offset::Real=0.0f0, spk_args::SpikingArgs)\n\nConvert a single phase value to a sequence of complex potentials at specified time points for a Resonate-and-Fire (R&F) neuron.\n\nArguments\n\nphase::Real: Phase value in range [-1, 1]\nts::AbstractVector: Vector of time points at which to compute the potential\noffset::Real=0.0f0: Time offset for phase calculations\nspk_args::SpikingArgs: Spiking neuron parameters\n\nReturns\n\nVector of complex potentials, one for each time point in ts\n\nDetails\n\nThe R&F neuron potential follows a circular trajectory in the complex plane, with its phase determined by the input phase and time point. The trajectory's frequency and damping are specified in spk_args.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.phase_to_potential-Tuple{Real, Real}","page":"Domains","title":"PhasorNetworks.phase_to_potential","text":"phase_to_potential(phase::Real, t::Real; offset::Real=0.0f0, spk_args::SpikingArgs)\n\nConvert a single phase value to a complex potential at a specific time point. This is the core implementation of the phase-to-potential conversion.\n\nArguments\n\nphase::Real: Phase value in range [-1, 1]\nt::Real: Time point at which to compute the potential\noffset::Real=0.0f0: Time offset for phase calculations\nspk_args::SpikingArgs: Spiking neuron parameters\n\nReturns\n\nComplex number representing the neuron's potential at time t\n\nDetails\n\nThe potential is computed as: z(t) = exp(ik * (t - offset - (phase - 1)/2 * period)) where k is the neuron's complex frequency constant (incorporating both oscillation frequency and leakage/damping).\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.phase_to_time","page":"Domains","title":"PhasorNetworks.phase_to_time","text":"phase_to_time(phases::AbstractArray, period::Real, offset::Real = 0.0f0)\n\nConvert phases to spike times using a specified oscillation period. This is the core implementation that handles the actual conversion math.\n\nArguments\n\nphases::AbstractArray: Array of phases in range [-1, 1]\nperiod::Real: Oscillation period length\noffset::Real = 0.0f0: Time offset to add to all spike times\n\nReturns\n\nArray of spike times in absolute time units, normalized to be within [0, period)\n\nDetails\n\nThe conversion maps phase φ to time t as: t = (φ/2 + 0.5) * period + offset followed by modulo operation to ensure positive times within one period.\n\n\n\n\n\n","category":"function"},{"location":"api/domains/#PhasorNetworks.phase_to_time-Tuple{AbstractArray}","page":"Domains","title":"PhasorNetworks.phase_to_time","text":"phase_to_time(phases::AbstractArray; offset::Real = 0.0f0, spk_args::SpikingArgs)\n\nConvert phases to spike times using spiking neuron parameters. Phases are interpreted  as relative positions within a neuron's oscillation period.\n\nArguments\n\nphases::AbstractArray: Array of phases in range [-1, 1]\noffset::Real = 0.0f0: Time offset to add to all spike times\nspk_args::SpikingArgs: Spiking neuron parameters including oscillation period\n\nReturns\n\nArray of spike times in absolute time units\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.phase_to_train-Tuple{AbstractArray}","page":"Domains","title":"PhasorNetworks.phase_to_train","text":"phase_to_train(phases::AbstractArray; spk_args::SpikingArgs, repeats::Int = 1, offset::Real = 0.0f0)\n\nConvert an array of phases to a SpikeTrain object, optionally repeating the spike pattern multiple times.\n\nArguments\n\nphases::AbstractArray: Array of phases in range [-1, 1]\nspk_args::SpikingArgs: Spiking neuron parameters\nrepeats::Int = 1: Number of times to repeat the spike pattern\noffset::Real = 0.0f0: Time offset for the spike train\n\nReturns\n\nSpikeTrain: Object containing spike times and their corresponding indices\n\nDetails\n\nFor each non-NaN phase value, a spike is generated at the corresponding time. If repeats > 1, the spike pattern is repeated with appropriate time offsets. The spatial structure of the input array is preserved in the SpikeTrain's shape.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.potential_to_phase-Tuple{AbstractArray, Real}","page":"Domains","title":"PhasorNetworks.potential_to_phase","text":"Convert the potential of a neuron at an arbitrary point in time to its phase relative to a reference\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.potential_to_phase-Tuple{Tuple{AbstractVector{<:AbstractArray}, AbstractVector}}","page":"Domains","title":"PhasorNetworks.potential_to_phase","text":"potential_to_phase(ut::Tuple{<:AbstractVector{<:AbstractArray}, <:AbstractVector}; spk_args::SpikingArgs, kwargs...)\n\nDecodes the phase from a tuple of potentials and times, as produced by an ODESolution. This is a convenience function for handling the output of ODE solvers like (sol.u, sol.t).\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.potential_to_time-Tuple{AbstractArray, AbstractVector}","page":"Domains","title":"PhasorNetworks.potential_to_time","text":"potential_to_time(u::AbstractArray, ts::AbstractVector; spk_args::SpikingArgs, dim::Int=-1)\n\nCalculate spike times for an array of neuron potentials over multiple time points.\n\nArguments\n\nu::AbstractArray: Array of complex potentials\nts::AbstractVector: Vector of time points\nspk_args::SpikingArgs: Spiking neuron parameters\ndim::Int=-1: Dimension along which time varies (defaults to last dimension)\n\nReturns\n\nArray of predicted spike times with same shape as input\n\nThrows\n\nAssertionError if size along time dimension doesn't match length of ts\n\nDetails\n\nProcesses each time slice of the potential array separately, computing spike times for each potential at the corresponding time point. The results are stacked back together along the specified dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.potential_to_time-Tuple{AbstractArray, Real}","page":"Domains","title":"PhasorNetworks.potential_to_time","text":"potential_to_time(u::AbstractArray, t::Real; spk_args::SpikingArgs)\n\nCalculate expected spike times for an array of neuron potentials at a given time.\n\nArguments\n\nu::AbstractArray: Array of complex potentials\nt::Real: Current time point\nspk_args::SpikingArgs: Spiking neuron parameters\n\nReturns\n\nArray of predicted spike times\n\nDetails\n\nFor each complex potential:\n\nCalculates angle in complex plane\nDetermines angular distance to π/2 (spiking threshold)\nConverts this angle to time using neuron frequency\nAdds to current time to get absolute spike time\nEnsures all times are positive by adding period if needed\n\nThe spiking angle π/2 represents the phase at which a neuron generates a spike in the Resonate-and-Fire model.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.realvec_to_cmpx-Tuple{Array{<:Real}}","page":"Domains","title":"PhasorNetworks.realvec_to_cmpx","text":"realvec_to_cmpx(u::Array{<:Real})\n\nConvert a real-valued array with a leading dimension of size 2 back to complex numbers. The first slice along dimension 1 becomes the real part, and the second slice becomes the imaginary part.\n\nArguments\n\nu::Array{<:Real}: Input array with shape (2, ...)\n\nReturns\n\nComplex array with shape matching input dimensions excluding the first\n\nThrows\n\nAssertionError if first dimension is not of size 2\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.soft_angle","page":"Domains","title":"PhasorNetworks.soft_angle","text":"soft_angle(x::AbstractArray{<:Complex}, r_lo::Real = 0.1f0, r_hi::Real = 0.2f0)\n\nCalculate angles of complex numbers with a soft threshold based on magnitude. The output is scaled by a sigmoid function of the magnitude, which smoothly  transitions between 0 and 1 in the range [rlo, rhi].\n\nArguments\n\nx::AbstractArray{<:Complex}: Array of complex numbers\nr_lo::Real = 0.1f0: Lower threshold for magnitude scaling\nr_hi::Real = 0.2f0: Upper threshold for magnitude scaling\n\nReturns\n\nArray of angles in units of π radians, scaled by magnitude-dependent sigmoid\n\n\n\n\n\n","category":"function"},{"location":"api/domains/#PhasorNetworks.solution_to_phase-Tuple{SciMLBase.ODESolution}","page":"Domains","title":"PhasorNetworks.solution_to_phase","text":"solution_to_phase(sol::ODESolution; final_t::Bool=false, offset::Real=0.0f0, \n                 spk_args::SpikingArgs, kwargs...)\n\nConvert an ODESolution to phases, either at all time points or just the final time.\n\nArguments\n\nsol::ODESolution: ODE solution object\nfinal_t::Bool=false: If true, only compute phase at final time point\noffset::Real=0.0f0: Time offset for phase calculations\nspk_args::SpikingArgs: Spiking neuron parameters\nkwargs...: Additional arguments passed to potentialtophase\n\nReturns\n\nIf final_t is true: Array of phases at final time point\nIf final_t is false: Array of phases at all saved time points\n\nDetails\n\nConverts the ODE solution to potentials and then to phases. Can either process the entire time series or just the final state, which is useful for different analysis scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.solution_to_phase-Tuple{Union{Function, SciMLBase.ODESolution}, Array}","page":"Domains","title":"PhasorNetworks.solution_to_phase","text":"solution_to_phase(sol::Union{ODESolution, Function}, t::Array; offset::Real=0.0f0, \n                 spk_args::SpikingArgs, kwargs...)\n\nConvert a solution (ODE or function) to phases at specified time points.\n\nArguments\n\nsol::Union{ODESolution, Function}: ODE solution object or interpolating function\nt::Array: Array of time points at which to compute phases\noffset::Real=0.0f0: Time offset for phase calculations\nspk_args::SpikingArgs: Spiking neuron parameters\nkwargs...: Additional arguments passed to potentialtophase\n\nReturns\n\nArray of phases at the specified time points\n\nDetails\n\nEvaluates the solution at given time points, converts to potentials, and then computes the corresponding phases. This allows for flexible sampling of the solution's phase representation at arbitrary time points.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.solution_to_potential-Tuple{SciMLBase.ODESolution}","page":"Domains","title":"PhasorNetworks.solution_to_potential","text":"solution_to_potential(ode_sol::ODESolution)\n\nConvert an ODESolution directly to an array of complex potentials.\n\nArguments\n\node_sol::ODESolution: ODE solution object\n\nReturns\n\nArray of complex potentials sampled at the solution's saved time points\n\nDetails\n\nSimple conversion of an ODESolution to an array format, using the solution's internally saved time points. Useful when you want to work with the exact time points at which the ODE solver saved its results.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.solution_to_potential-Tuple{Union{Function, SciMLBase.ODESolution}, Array}","page":"Domains","title":"PhasorNetworks.solution_to_potential","text":"solution_to_potential(func_sol::Union{ODESolution, Function}, t::Array)\n\nConvert a solution function or ODESolution to an array of complex potentials at specified times.\n\nArguments\n\nfunc_sol::Union{ODESolution, Function}: ODE solution object or interpolating function\nt::Array: Array of time points at which to evaluate the solution\n\nReturns\n\nArray of complex potentials with time as the last dimension\n\nDetails\n\nTakes a solution (either as a function or ODESolution object) and evaluates it at specified time points, stacking the results along a new final dimension. This is useful for converting continuous solution functions into discretely sampled arrays of potentials.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.solution_to_train-Tuple{AbstractArray{<:Complex}, AbstractVector{<:Real}}","page":"Domains","title":"PhasorNetworks.solution_to_train","text":"This implementation takes a single matrix at pre-selected, representative times and converts each temporal slice to spikes.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.solution_to_train-Tuple{AbstractVector{<:AbstractArray}, AbstractVector{<:Real}, Tuple{Real, Real}}","page":"Domains","title":"PhasorNetworks.solution_to_train","text":"This implementation takes a full solution (represented by a vector of arrays) and finds the spikes from it.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.solution_to_train-Tuple{Union{Function, SciMLBase.ODESolution}, Tuple{Real, Real}}","page":"Domains","title":"PhasorNetworks.solution_to_train","text":"solution_to_train(sol::Union{ODESolution,Function}, tspan::Tuple{<:Real, <:Real}; \n                 spk_args::SpikingArgs, offset::Real)\n\nConvert a continuous ODE solution or interpolating function to a discrete spike train by sampling at cycle boundaries.\n\nArguments\n\nsol::Union{ODESolution,Function}: Either an ODESolution object or a function that can be evaluated at arbitrary time points to get the system state\ntspan::Tuple{<:Real, <:Real}: Time span (tstart, tend) over which to generate spikes\nspk_args::SpikingArgs: Spiking neuron parameters\noffset::Real: Time offset for spike timing calculations\n\nReturns\n\nSpikeTrain: Object containing the detected spikes and their timing information\n\nDetails\n\nDetermines cycle boundary times within the specified time span\nSamples the solution at these cycle boundaries\nConverts the sampled potentials to spike times using threshold detection\n\nThis function provides a way to discretize a continuous dynamical solution into a sequence of spikes, which is useful for analyzing the system's behavior in terms of discrete events.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.time_to_phase-Tuple{AbstractArray, Real, Real}","page":"Domains","title":"PhasorNetworks.time_to_phase","text":"time_to_phase(times::AbstractArray, period::Real, offset::Real)\n\nConvert spike times to phases using a specified oscillation period. This is the inverse operation of phasetotime.\n\nArguments\n\ntimes::AbstractArray: Array of spike times\nperiod::Real: Oscillation period length\noffset::Real: Time offset to subtract from all spike times\n\nReturns\n\nArray of phases in range [-1, 1]\n\nDetails\n\nThe conversion maps time t to phase φ as: φ = 2(((t - offset) mod period)/period - 0.5)\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.time_to_phase-Tuple{AbstractArray}","page":"Domains","title":"PhasorNetworks.time_to_phase","text":"time_to_phase(times::AbstractArray; spk_args::SpikingArgs, offset::Real)\n\nConvert spike times to phases using spiking neuron parameters. This is a convenience wrapper that uses the neuron's period from spk_args.\n\nArguments\n\ntimes::AbstractArray: Array of spike times\nspk_args::SpikingArgs: Spiking neuron parameters containing period information\noffset::Real: Time offset to subtract from all spike times\n\nReturns\n\nArray of phases in range [-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.time_to_potential-Tuple{AbstractArray, AbstractVector}","page":"Domains","title":"PhasorNetworks.time_to_potential","text":"time_to_potential(spikes::AbstractArray, ts::AbstractVector; spk_args::SpikingArgs, dim::Int=-1)\n\nCalculate complex potentials over multiple time points for neurons with specified spike times.\n\nArguments\n\nspikes::AbstractArray: Array of spike times\nts::AbstractVector: Vector of time points at which to compute potentials\nspk_args::SpikingArgs: Spiking neuron parameters\ndim::Int=-1: Dimension along which time varies (defaults to last dimension)\n\nReturns\n\nArray of complex potentials with same shape as input\n\nThrows\n\nAssertionError if size along time dimension doesn't match length of ts\n\nDetails\n\nProcesses each time slice of the spike times array separately, computing potentials at each corresponding time point. The results are stacked back together along the specified dimension, maintaining the original array structure.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.time_to_potential-Tuple{AbstractArray, Real}","page":"Domains","title":"PhasorNetworks.time_to_potential","text":"time_to_potential(spikes::AbstractArray, t::Real; spk_args::SpikingArgs)\n\nCalculate complex potentials at a given time for neurons that spiked at specified times.\n\nArguments\n\nspikes::AbstractArray: Array of spike times\nt::Real: Time at which to compute the potentials\nspk_args::SpikingArgs: Spiking neuron parameters\n\nReturns\n\nArray of complex potentials\n\nDetails\n\nFor each spike time:\n\nComputes time elapsed since/until spike\nConverts to angular displacement using neuron frequency\nAdjusts relative to spiking angle (π/2)\nConverts to complex potential on unit circle\n\nThe resulting potentials represent the state each neuron would have at time t, given their spike times, assuming ideal oscillatory behavior.\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.train_to_phase-Tuple{SpikeTrainGPU}","page":"Domains","title":"PhasorNetworks.train_to_phase","text":"train_to_phase(train::SpikeTrainGPU; spk_args::SpikingArgs)\n\nConvert a GPU-based spike train to phases. The output remains on the GPU.\n\nArguments\n\ntrain::SpikeTrainGPU: GPU-based spike train\nspk_args::SpikingArgs: Spiking neuron parameters\n\nReturns\n\nGPU array of phases in range [-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.train_to_phase-Tuple{SpikeTrain}","page":"Domains","title":"PhasorNetworks.train_to_phase","text":"train_to_phase(train::SpikeTrain; spk_args::SpikingArgs, offset::Real = 0.0f0)\n\nConvert a spike train to a sequence of phase snapshots, one for each oscillation cycle. For each cycle, creates a phase array matching the original spatial dimensions, with  NaN values for neurons that did not spike in that cycle.\n\nArguments\n\ntrain::SpikeTrain: The spike train to convert\nspk_args::SpikingArgs: Spiking neuron parameters\noffset::Real = 0.0f0: Additional time offset for phase calculation\n\nReturns\n\nArray of phases with shape (originalshape..., ncycles), where n_cycles is determined by the temporal span of the spike train. Each slice along the last dimension represents the phases in one oscillation cycle.\nReturns missing if the spike train is empty\n\nThrows\n\nAssertionError if any spike times are negative\n\nDetails\n\nConverts each spike time to a phase within its cycle\nDetermines which cycle each spike belongs to\nCreates a phase array for each cycle, filling with NaN by default\nPlaces each spike's phase in the appropriate cycle and spatial location\nStacks all cycles into a single array along a new final dimension\n\n\n\n\n\n","category":"method"},{"location":"api/domains/#PhasorNetworks.train_to_phase-Tuple{SpikingCall}","page":"Domains","title":"PhasorNetworks.train_to_phase","text":"train_to_phase(call::SpikingCall)\n\nConvert a SpikingCall's spike train to phases using its own spiking parameters.\n\nArguments\n\ncall::SpikingCall: Contains a spike train and associated spiking parameters\n\nReturns\n\nArray of phases in range [-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/network/#Network-API","page":"Networks","title":"Network API","text":"Documentation for neural network implementations.","category":"section"},{"location":"api/network/#Core.Union-Tuple{SpikingCall, Union{AbstractArray, NamedTuple}, NamedTuple}","page":"Networks","title":"Core.Union","text":"(m::Union{MaxPool, MinPool})(x::SpikingCall, ps::LuxParams, st::NamedTuple)\n\nExtend MaxPool to handle SpikeTrain inputs by selecting the spike with maximum decoded phase value over the pooling dimensions.\n\nArguments\n\nx::SpikingCall: Input spiking call\nps::LuxParams: Layer parameters\nst::NamedTuple: Layer state\n\nOperation\n\nConverts each spike to its corresponding phase value using train_to_phase\nFinds the maximum phase value over the pooling dimensions\nReturns a new SpikeTrain with the selected spike(s), preserving temporal offset\n\nReturns\n\noutput_train::SpikeTrain: Spike train containing only maximum phase spikes\nst::NamedTuple: Unchanged state\n\n\n\n\n\n","category":"method"},{"location":"api/network/#PhasorNetworks.Codebook","page":"Networks","title":"PhasorNetworks.Codebook","text":"Codebook <: LuxCore.AbstractLuxLayer\n\nLayer that accesses a fixed set of phase codes and computes similarities with inputs. Used for discrete embedding or classification tasks in phase-based networks.\n\nFields\n\ndims::Pair{<:Int, <:Int}: Input dimension => Number of codes\n\nState\n\ncodes: Random phase symbols initialized as the codebook\nCodes are fixed after initialization (non-trainable)\n\nForward Pass\n\nFor phase inputs: Computes similarity with all codes\nFor spiking inputs: Converts codes to currents and computes temporal similarity\n\nUse Cases\n\nDiscrete symbol encoding in Vector Symbolic Architectures\nClassification by similarity to learned phase patterns\nPhase-based memory or lookup mechanisms\n\nSee also: similarity_outer for similarity computation\n\n\n\n\n\n","category":"type"},{"location":"api/network/#PhasorNetworks.ComplexBias","page":"Networks","title":"PhasorNetworks.ComplexBias","text":"ComplexBias <: LuxCore.AbstractLuxLayer\n\nLayer that adds learnable complex-valued biases to phase networks.\n\nFields\n\ndims: Dimensions of the bias terms\ninit_bias: Function to initialize bias values (default: ones)\n\nInitialization Options\n\ndefault_bias: Initialize with ones in complex plane\nzero_bias: Initialize with zeros\nCustom initialization function with signature (rng, dims) -> ComplexF32 array\n\nUsed as a component in PhasorDense and PhasorConv layers to provide phase shifts in the complex plane.\n\n\n\n\n\n","category":"type"},{"location":"api/network/#PhasorNetworks.MakeSpiking","page":"Networks","title":"PhasorNetworks.MakeSpiking","text":"MakeSpiking - a layer to include in Chains to convert phase tensors into SpikeTrains\n\n\n\n\n\n","category":"type"},{"location":"api/network/#PhasorNetworks.PhasorConv","page":"Networks","title":"PhasorNetworks.PhasorConv","text":"PhasorConv <: LuxCore.AbstractLuxContainerLayer{(:layer, :bias)}\n\nConvolutional layer for phase-valued inputs and spiking neural networks. Implements complex-valued convolution with phase-based activation.\n\nFields\n\nlayer: Standard convolutional layer for spatial operations\nbias: Complex-valued bias terms\nactivation: Phase activation function\nuse_bias::Bool: Whether to apply complex bias\nreturn_type::SolutionType: Output format for spiking inputs (:phase, :potential, :current, or :spiking)\n\nImplementation\n\nSeparates input into real/imaginary components\nApplies convolution separately to each component\nRecombines into complex values\nOptionally applies complex bias and activation\n\nSee also: PhasorDense for fully-connected equivalent\n\n\n\n\n\n","category":"type"},{"location":"api/network/#PhasorNetworks.PhasorDense","page":"Networks","title":"PhasorNetworks.PhasorDense","text":"PhasorDense <: LuxCore.AbstractLuxContainerLayer{(:layer, :bias)}\n\nA dense (fully-connected) layer that operates on phase/complex-valued inputs. Combines a standard dense layer with complex bias and phase-based activation.\n\nFields\n\nlayer: Standard dense layer for linear transformation\nbias: Complex-valued bias for phase shift\nactivation: Function to convert complex values to phases\nuse_bias::Bool: Whether to apply complex bias\nreturn_type::SolutionType: Output format for spiking inputs (:phase, :potential, :current, or :spiking)\n\nLayer Operation\n\nConverts input phases to complex numbers\nApplies linear transformation separately to real/imaginary parts\nOptionally applies complex bias\nApplies activation function to map back to phases\n\nSupports both direct phase inputs and spiking inputs through ODEs.\n\n\n\n\n\n","category":"type"},{"location":"api/network/#PhasorNetworks.ResidualBlock","page":"Networks","title":"PhasorNetworks.ResidualBlock","text":"ResidualBlock <: LuxCore.AbstractLuxContainerLayer{(:ff,)}\n\nResidual block for phase-based neural networks, implementing skip connections through phase binding.\n\nFields\n\nff: Feed-forward chain of phase-based layers\n\nImplementation Details\n\nProcesses input through feed-forward path\nBinds (combines) original input with processed output\nMaintains phase-based representation throughout\n\nUsed to build deep phase networks while mitigating phase degradation, similar to residual connections in standard neural networks but using phase binding for combination.\n\nSee also: v_bind for the phase binding operation\n\n\n\n\n\n","category":"type"},{"location":"api/network/#PhasorNetworks.SingleHeadAttention","page":"Networks","title":"PhasorNetworks.SingleHeadAttention","text":"SingleHeadAttention <: LuxCore.AbstractLuxContainerLayer{(:q_proj, :k_proj, :v_proj, :attention, :out_proj)}\n\nSingle-head attention mechanism for phase-based transformers. Implements attention using phase similarity for key-query interactions.\n\nFields\n\nq_proj: Query projection layer\nk_proj: Key projection layer\nv_proj: Value projection layer\nattention: Attention scoring mechanism\nout_proj: Output projection layer\n\nImplementation Details\n\nProjects input to query/key/value representations\nComputes attention scores using phase similarity\nCombines values weighted by attention scores\nProjects combined values to output space\n\nCan operate on both direct phase inputs and spiking representations. See also: attend for the core attention computation\n\n\n\n\n\n","category":"type"},{"location":"api/network/#PhasorNetworks.TrackOutput","page":"Networks","title":"PhasorNetworks.TrackOutput","text":"TrackOutput{L<:Lux.AbstractLuxLayer} <: Lux.AbstractLuxLayer\n\nWrapper layer that records intermediate outputs during forward passes. Useful for analyzing internal representations in phase networks.\n\nFields\n\nlayer::L: The layer whose outputs to track\n\nState\n\nMaintains a tuple of all intermediate outputs in the state.outputs field. Each forward pass appends its output to this tuple.\n\nUsage\n\ntracked_layer = TrackOutput(PhasorDense(64 => 32))\ny, st = tracked_layer(x, ps, st)\nintermediate_outputs = st.outputs  # Access all recorded outputs\n\nUseful for visualization, analysis, and debugging of phase networks.\n\n\n\n\n\n","category":"type"},{"location":"api/network/#LuxLib.API.dropout-Union{Tuple{T}, Tuple{Random.AbstractRNG, SpikingCall, T, Any, T, Any}} where T","page":"Networks","title":"LuxLib.API.dropout","text":"Extension of dropout to SpikeTrains\n\n\n\n\n\n","category":"method"},{"location":"api/network/#PhasorNetworks.attend-Tuple{Union{SpikeTrain, SpikeTrainGPU}, Union{SpikeTrain, SpikeTrainGPU}, Union{SpikeTrain, SpikeTrainGPU}}","page":"Networks","title":"PhasorNetworks.attend","text":"attend(q::SpikingTypes, k::SpikingTypes, v::SpikingTypes; spk_args, tspan, return_solution=false, scale=[1.0f0]) -> Tuple\n\nCompute attention between spiking neural representations using phase similarity. Core attention mechanism for spiking transformer architectures.\n\nArguments\n\nq, k, v: Query, key, and value spike trains\nspk_args::SpikingArgs: Spiking neuron parameters\ntspan: Time span for simulation\nreturn_solution::Bool: Whether to return raw potentials\nscale::AbstractArray: Attention scaling factor\n\nImplementation\n\nComputes temporal similarity between query and key spikes\nConverts value spikes to oscillator potentials\nScales and combines values based on similarities\nOptionally converts back to spike train\n\nReturns:\n\nSpike train or potentials representing attended values\nAttention scores over time\n\nSee also: attend for phase-based version\n\n\n\n\n\n","category":"method"},{"location":"api/network/#PhasorNetworks.score_scale-Tuple{AbstractArray{<:Real, 3}}","page":"Networks","title":"PhasorNetworks.score_scale","text":"Phasor QKV Attention\n\n\n\n\n\n","category":"method"},{"location":"api/network/#PhasorNetworks.train-NTuple{6, Any}","page":"Networks","title":"PhasorNetworks.train","text":"train(model, ps, st, train_loader, loss, args; optimiser=Optimisers.Adam, verbose=false, sample_gradients=0)\n\nTrain a phase-based neural network using gradient descent.\n\nArguments\n\nmodel: Network model (any Lux.jl compatible architecture)\nps: Model parameters\nst: Model state\ntrain_loader: Data loader providing (x, y) batches\nloss: Loss function(x, y, model, params, state)\nargs::Args: Training configuration\noptimiser: Optimization algorithm (default: Adam)\nverbose::Bool: Whether to print loss values\nsample_gradients::Int: Frequency of gradient sampling (0 to disable)\n\nReturns\n\nlosses: Array of loss values during training\nps: Updated parameters\nst: Updated state\ngradients: Sampled gradients if enabled\n\nAutomatically handles CPU/GPU device placement based on args.use_cuda.\n\n\n\n\n\n","category":"method"},{"location":"api/network/#PhasorNetworks.variance_scaling-Tuple{Random.AbstractRNG, Vararg{Integer}}","page":"Networks","title":"PhasorNetworks.variance_scaling","text":"variance_scaling(rng::AbstractRNG, shape::Integer...; mode=\"avg\", scale=0.66f0)\n\nInitialize network weights using variance scaling initialization. Adapts the scale based on input/output dimensions to maintain stable variances.\n\nArguments\n\nrng::AbstractRNG: Random number generator\nshape::Integer...: Dimensions of weight matrix/tensor\nmode::String: Scaling mode (\"fanin\", \"fanout\", or \"avg\")\nscale::Real: Base scaling factor (default: 0.66f0)\n\nModes\n\n\"fan_in\": Scale based on input dimension\n\"fan_out\": Scale based on output dimension\n\"avg\": Scale based on average of input/output dimensions\n\nReturns weights initialized from truncated normal distribution with computed standard deviation.\n\n\n\n\n\n","category":"method"},{"location":"#PhasorNetworks.jl","page":"Home","title":"PhasorNetworks.jl","text":"PhasorNetworks.jl is a Julia package for implementing and simulating phasor neural networks, combining concepts from oscillatory computing and neuromorphic engineering.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Phasor Neural Networks: Implementation of neural networks using phase-based computation\nSpiking Neural Networks: Tools for working with spiking neural networks and spike trains\nVector Symbolic Architecture: Operations for VSA-based computations\nGPU Acceleration: CUDA support for large-scale simulations\nDomain Transformations: Utilities for converting between different neural representations\nPerformance Metrics: Tools for analyzing and evaluating network performance","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"PhasorNetworks\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using PhasorNetworks\n\n# Create a basic phasor network\nspk_args = SpikingArgs_NN(\n    t_period = 1.0f0,\n    t_window = 0.01f0,\n    threshold = 0.001f0\n)\n\n# Example code will go here...","category":"section"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"The package functionality is organized into several core components:\n\nTypes: Core types and type system\nNetworks: Neural network implementation\nSpiking: Spiking neural network functionality\nDomains: Domain transformation utilities\nVSA: Vector Symbolic Architecture operations\nGPU: GPU acceleration support\nMetrics: Performance metrics and analysis\n\nSee the respective API documentation pages for detailed information about each component.\n\nPages = [\"api/types.md\", \"api/network.md\", \"api/spiking.md\", \"api/domains.md\", \n         \"api/vsa.md\", \"api/gpu.md\", \"api/metrics.md\"]","category":"section"},{"location":"api/spiking/#Spiking-API","page":"Spiking","title":"Spiking API","text":"Documentation for spiking neural network functionality.","category":"section"},{"location":"api/spiking/#PhasorNetworks.delay_train-Tuple{Union{SpikeTrain, SpikeTrainGPU}, Real, Real}","page":"Spiking","title":"PhasorNetworks.delay_train","text":"delay_train(train::SpikingTypes, t::Real, offset::Real) -> SpikingTypes\n\nCreate a new spike train with all spike times shifted by a delay. Preserves the type (CPU/GPU) of the input train.\n\nArguments\n\ntrain::SpikingTypes: Input spike train\nt::Real: Time delay to add to all spikes\noffset::Real: Additional offset for phase alignment\n\nThe function:\n\nShifts all spike times by t\nAdjusts the train's offset by the specified amount\nMaintains spatial indices and shape\nReturns new train of same type as input (SpikeTrain or SpikeTrainGPU)\n\nUsed in match_offsets to align spike trains for comparison or combination.\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.find_spikes_rf-Tuple{AbstractArray, AbstractVector, SpikingArgs}","page":"Spiking","title":"PhasorNetworks.find_spikes_rf","text":"find_spikes_rf(u::AbstractArray, t::AbstractVector, spk_args::SpikingArgs; dim::Int=-1) -> Tuple{Vector{CartesianIndex}, Vector{Float32}}\nfind_spikes_rf(sol::ODESolution, spk_args::SpikingArgs; dim::Int=-1) -> Tuple{Vector{CartesianIndex}, Vector{Float32}}\n\nDetect spikes in resonate-and-fire neuron potentials by analyzing voltage peaks.\n\nArguments\n\nu::AbstractArray: Complex-valued neuron potentials (voltage = imag, current = real)\nt::AbstractVector: Time points corresponding to potentials\nspk_args::SpikingArgs: Neuron parameters including threshold\ndim::Int=-1: Dimension along which to find spikes (default: last dimension)\n\nDetection Method\n\nExtracts voltage (imaginary) and current (real) components\nFinds local voltage maxima using current zero-crossings\nApplies threshold to identify spikes\nMaps spikes to spatial locations and times\n\nReturns tuple of:\n\nSpatial indices of spiking neurons as CartesianIndices\nTimes at which spikes occurred\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.match_offsets-Tuple{Union{SpikeTrain, SpikeTrainGPU}, Union{SpikeTrain, SpikeTrainGPU}}","page":"Spiking","title":"PhasorNetworks.match_offsets","text":"Delay spike trains as necessary to make the represented phases between them match\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.match_offsets-Tuple{Vector{<:Union{SpikeTrain, SpikeTrainGPU}}}","page":"Spiking","title":"PhasorNetworks.match_offsets","text":"Delay the spike trains in a vector as necessary to make their offsets match\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.normalize_potential-Tuple{Complex}","page":"Spiking","title":"PhasorNetworks.normalize_potential","text":"normalize_potential(u::Complex) -> Complex\nnormalize_potential(a::AbstractArray) -> AbstractArray\n\nNormalize complex potentials to unit magnitude while preserving phase. Used to analyze phase relationships independent of amplitude.\n\nArguments\n\nu::Complex: Single complex potential\na::AbstractArray: Array of complex potentials\n\nHandles zero potentials by returning them unchanged. Non-zero potentials are divided by their magnitude.\n\nReturns normalized complex values with |z| = 1 or 0.\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.oscillator_bank-Tuple{Union{SpikeTrain, SpikeTrainGPU}}","page":"Spiking","title":"PhasorNetworks.oscillator_bank","text":"oscillator_bank(x::SpikingTypes; tspan, spk_args::SpikingArgs) -> ODESolution\n\nSimulate a bank of oscillator neurons driven by spike inputs. Core implementation of spiking neural network dynamics.\n\nArguments\n\nx::SpikingTypes: Input spike train (CPU or GPU)\ntspan::Tuple{<:Real, <:Real}: Time interval for simulation\nspk_args::SpikingArgs: Neuron parameters\n\nImplementation\n\nConverts spike train to continuous current function\nCreates LocalCurrent object for simulation\nSimulates neural ODEs using specified solver\n\nReturns ODESolution containing the network's temporal evolution.\n\nSee also: oscillator_bank variants for different input types and architectures\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.spike_current-Tuple{SpikeTrain, Real, SpikingArgs}","page":"Spiking","title":"PhasorNetworks.spike_current","text":"spike_current(train::SpikeTrain, t::Real, spk_args::SpikingArgs; sigma::Real = 9.0f0) -> Array{Float32}\n\nCompute the current induced by spikes at a given time point. Implements the conversion from discrete spikes to continuous currents using a kernel function.\n\nArguments\n\ntrain::SpikeTrain: Input spike train\nt::Real: Time at which to compute current\nspk_args::SpikingArgs: Neuron parameters including kernel type and scale\nsigma::Real=9.0f0: Width multiplier for active time window\n\nImplementation Details\n\nIdentifies active spikes within time window [t - σ⋅t_window, t + σ⋅t_window]\nApplies specified kernel (custom function or :gaussian) to active spikes\nScales and accumulates currents at spike locations\nUses ignore_derivatives for gradient stability\n\nSee also: spike_current for GPU implementation with SpikeTrainGPU\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.stack_trains-Tuple{Vector{<:SpikeTrain}}","page":"Spiking","title":"PhasorNetworks.stack_trains","text":"stack_trains(trains::Array{<:SpikeTrain,1}) -> SpikeTrain\n\nCombine multiple spike trains by stacking them along a new first dimension. Used for batching or combining parallel neural populations.\n\nArguments\n\ntrains::Array{<:SpikeTrain,1}: Array of spike trains to stack\n\nRequirements\n\nAll trains must have identical shapes\nAll trains must have identical time offsets\n\nImplementation\n\nVerifies compatibility of input trains\nCreates new shape with added dimension\nRemaps spike indices to include stack dimension\nConcatenates all spike times\n\nExample:\n\n# If A, B are trains with shape (10, 20)\nC = stack_trains([A, B])  # shape becomes (2, 10, 20)\n\nSee also: vcat_trains for concatenating along existing dimensions\n\n\n\n\n\n","category":"method"},{"location":"api/spiking/#PhasorNetworks.vcat_trains-Tuple{Vararg{SpikeTrain}}","page":"Spiking","title":"PhasorNetworks.vcat_trains","text":"vcat_trains(trains::SpikingTypes...) -> SpikingTypes\n\nConcatenate multiple spike trains by combining their spikes into a single train.\n\nAll input trains must have identical shapes and offsets. The resulting train contains all spikes from all input trains, preserving temporal information.\n\nArguments\n\ntrains::SpikingTypes...: Variable number of spike trains to concatenate\n\nReturns\n\nSpikeTrain or SpikeTrainGPU: Combined spike train with all input spikes\n\nRequirements\n\nAll input trains must have identical shapes\nAll input trains must have identical offsets\n\n\n\n\n\n","category":"method"}]
}
