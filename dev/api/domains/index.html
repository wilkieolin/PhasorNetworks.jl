<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Domains · PhasorNetworks.jl</title><meta name="title" content="Domains · PhasorNetworks.jl"/><meta property="og:title" content="Domains · PhasorNetworks.jl"/><meta property="twitter:title" content="Domains · PhasorNetworks.jl"/><meta name="description" content="Documentation for PhasorNetworks.jl."/><meta property="og:description" content="Documentation for PhasorNetworks.jl."/><meta property="twitter:description" content="Documentation for PhasorNetworks.jl."/><meta property="og:url" content="https://wilkieolin.github.io/PhasorNetworks.jl/api/domains/"/><meta property="twitter:url" content="https://wilkieolin.github.io/PhasorNetworks.jl/api/domains/"/><link rel="canonical" href="https://wilkieolin.github.io/PhasorNetworks.jl/api/domains/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhasorNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../network/">Networks</a></li><li><a class="tocitem" href="../spiking/">Spiking</a></li><li class="is-active"><a class="tocitem" href>Domains</a></li><li><a class="tocitem" href="../vsa/">VSA</a></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li><a class="tocitem" href="../metrics/">Metrics</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Domains</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Domains</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/wilkieolin/PhasorNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/main/docs/src/api/domains.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Domains-API"><a class="docs-heading-anchor" href="#Domains-API">Domains API</a><a id="Domains-API-1"></a><a class="docs-heading-anchor-permalink" href="#Domains-API" title="Permalink"></a></h1><p>Documentation for domain transformation functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.angfreq_to_period-Tuple{Real}" href="#PhasorNetworks.angfreq_to_period-Tuple{Real}"><code>PhasorNetworks.angfreq_to_period</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angfreq_to_period(angfreq::Real)</code></pre><p>Convert an angular frequency to time period.</p><p><strong>Arguments</strong></p><ul><li><code>angfreq::Real</code>: Angular frequency (ω) in radians per unit time</li></ul><p><strong>Returns</strong></p><ul><li>Time period (τ = 2π/ω)</li></ul><p><strong>Details</strong></p><p>This function is auto-inverting due to the reciprocal relationship between period and angular frequency. The implementation uses period<em>to</em>angfreq since τ = 2π/ω = 2π/(2π/τ₀) = τ₀.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L690-L705">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.angle_to_complex-Tuple{AbstractArray}" href="#PhasorNetworks.angle_to_complex-Tuple{AbstractArray}"><code>PhasorNetworks.angle_to_complex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angle_to_complex(x::AbstractArray)</code></pre><p>Convert an array of angles (in units of π radians) to complex numbers on the unit circle. Each angle θ is mapped to exp(iπθ), resulting in complex numbers with unit magnitude.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: Array of angles in units of π radians</li></ul><p><strong>Returns</strong></p><ul><li>Complex array where each element is exp(iπθ) for the corresponding angle θ</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.cmpx_to_realvec-Tuple{Array{&lt;:Complex}}" href="#PhasorNetworks.cmpx_to_realvec-Tuple{Array{&lt;:Complex}}"><code>PhasorNetworks.cmpx_to_realvec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cmpx_to_realvec(u::Array{&lt;:Complex})</code></pre><p>Convert an array of complex numbers to a real-valued array by stacking real and imaginary parts. The output array has an additional first dimension of size 2, containing real parts in index 1 and imaginary parts in index 2.</p><p><strong>Arguments</strong></p><ul><li><code>u::Array{&lt;:Complex}</code>: Input array of complex numbers</li></ul><p><strong>Returns</strong></p><ul><li>Array of real numbers with shape (2, size(u)...)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.complex_to_angle-Tuple{AbstractArray}" href="#PhasorNetworks.complex_to_angle-Tuple{AbstractArray}"><code>PhasorNetworks.complex_to_angle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complex_to_angle(x::AbstractArray)</code></pre><p>Convert an array of complex numbers to their angles in units of π radians.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: Array of complex numbers</li></ul><p><strong>Returns</strong></p><ul><li>Array of angles in units of π radians, in range [-1, 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.complex_to_angle-Tuple{Real, Real}" href="#PhasorNetworks.complex_to_angle-Tuple{Real, Real}"><code>PhasorNetworks.complex_to_angle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complex_to_angle(x_real::Real, x_imag::Real)</code></pre><p>Convert real and imaginary components to an angle in units of π radians.</p><p><strong>Arguments</strong></p><ul><li><code>x_real::Real</code>: Real component of complex number</li><li><code>x_imag::Real</code>: Imaginary component of complex number</li></ul><p><strong>Returns</strong></p><ul><li>Angle in units of π radians, in range [-1, 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.neuron_constant-Tuple{Real, Real}" href="#PhasorNetworks.neuron_constant-Tuple{Real, Real}"><code>PhasorNetworks.neuron_constant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neuron_constant(leakage::Real, t_period::Real)</code></pre><p>Calculate the complex frequency constant for a Resonate-and-Fire neuron.</p><p><strong>Arguments</strong></p><ul><li><code>leakage::Real</code>: Leakage/damping rate of the neuron</li><li><code>t_period::Real</code>: Oscillation period</li></ul><p><strong>Returns</strong></p><ul><li>Complex frequency constant k = λ + iω, where:<ul><li>λ is the leakage rate</li><li>ω is the angular frequency (2π/period)</li></ul></li></ul><p><strong>Details</strong></p><p>This complex constant determines both the frequency of oscillation and the rate of decay in the neuron&#39;s dynamics. The real part (leakage) controls damping, while the imaginary part sets the oscillation frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L711-L729">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.neuron_constant-Tuple{SpikingArgs}" href="#PhasorNetworks.neuron_constant-Tuple{SpikingArgs}"><code>PhasorNetworks.neuron_constant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neuron_constant(spk_args::SpikingArgs)</code></pre><p>Convenience function to calculate the neuron&#39;s complex frequency constant from SpikingArgs.</p><p><strong>Arguments</strong></p><ul><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters containing leakage and period</li></ul><p><strong>Returns</strong></p><ul><li>Complex frequency constant k = λ + iω using parameters from spk_args</li></ul><p><strong>Details</strong></p><p>This is a wrapper around neuron<em>constant(leakage, t</em>period) that extracts the parameters from a SpikingArgs struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L736-L750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.period_to_angfreq-Tuple{Real}" href="#PhasorNetworks.period_to_angfreq-Tuple{Real}"><code>PhasorNetworks.period_to_angfreq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">period_to_angfreq(t_period::Real)</code></pre><p>Convert a time period to angular frequency.</p><p><strong>Arguments</strong></p><ul><li><code>t_period::Real</code>: Time period (τ)</li></ul><p><strong>Returns</strong></p><ul><li>Angular frequency (ω = 2π/τ) in radians per unit time</li></ul><p><strong>Details</strong></p><p>Implements the standard relationship between period and angular frequency: ω = 2π/τ where τ is the period and ω is the angular frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L670-L684">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.phase_to_current-Tuple{AbstractArray}" href="#PhasorNetworks.phase_to_current-Tuple{AbstractArray}"><code>PhasorNetworks.phase_to_current</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_current(phases::AbstractArray; spk_args::SpikingArgs, offset::Real = 0.0f0, 
                tspan::Tuple{&lt;:Real, &lt;:Real}, rng::Union{AbstractRNG, Nothing} = nothing, 
                zeta::Real=Float32(0.0))</code></pre><p>Convert a set of phases to a time-varying current function using a Gaussian kernel. The current at each time point is computed based on the phase difference between the input phases and the current time, with optional noise.</p><p><strong>Arguments</strong></p><ul><li><code>phases::AbstractArray</code>: Array of phases in range [-1, 1]</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>offset::Real = 0.0f0</code>: Time offset for phase calculations</li><li><code>tspan::Tuple{&lt;:Real, &lt;:Real}</code>: Time span over which the current will be defined</li><li><code>rng::Union{AbstractRNG, Nothing} = nothing</code>: Random number generator for noise</li><li><code>zeta::Real=Float32(0.0)</code>: Noise amplitude (0 for no noise)</li></ul><p><strong>Returns</strong></p><ul><li><code>CurrentCall</code>: Object containing a LocalCurrent function that computes the current at any given time point, along with the spiking parameters and time span</li></ul><p><strong>Details</strong></p><p>The current is computed using a Gaussian kernel centered at each phase, with width determined by spk<em>args.t</em>window. Optional Gaussian noise can be added with amplitude zeta. The returned function preserves the input array&#39;s shape and can be evaluated at any time within the specified time span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L345-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.phase_to_potential-Tuple{AbstractArray, AbstractVector}" href="#PhasorNetworks.phase_to_potential-Tuple{AbstractArray, AbstractVector}"><code>PhasorNetworks.phase_to_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_potential(phase::AbstractArray, ts::AbstractVector; offset::Real=0.0f0, spk_args::SpikingArgs)</code></pre><p>Convert an array of phases to a matrix of complex potentials, computing the potential for each phase at each specified time point.</p><p><strong>Arguments</strong></p><ul><li><code>phase::AbstractArray</code>: Array of phase values in range [-1, 1]</li><li><code>ts::AbstractVector</code>: Vector of time points</li><li><code>offset::Real=0.0f0</code>: Time offset for phase calculations</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li></ul><p><strong>Returns</strong></p><ul><li>Matrix of complex potentials with size (length(phase), length(ts))</li></ul><p><strong>Details</strong></p><p>Creates a matrix where each row corresponds to a phase value and each column corresponds to a time point, containing the complex potential of an R&amp;F neuron with that phase at that time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L428-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.phase_to_potential-Tuple{Real, AbstractVector}" href="#PhasorNetworks.phase_to_potential-Tuple{Real, AbstractVector}"><code>PhasorNetworks.phase_to_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_potential(phase::Real, ts::AbstractVector; offset::Real=0.0f0, spk_args::SpikingArgs)</code></pre><p>Convert a single phase value to a sequence of complex potentials at specified time points for a Resonate-and-Fire (R&amp;F) neuron.</p><p><strong>Arguments</strong></p><ul><li><code>phase::Real</code>: Phase value in range [-1, 1]</li><li><code>ts::AbstractVector</code>: Vector of time points at which to compute the potential</li><li><code>offset::Real=0.0f0</code>: Time offset for phase calculations</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li></ul><p><strong>Returns</strong></p><ul><li>Vector of complex potentials, one for each time point in ts</li></ul><p><strong>Details</strong></p><p>The R&amp;F neuron potential follows a circular trajectory in the complex plane, with its phase determined by the input phase and time point. The trajectory&#39;s frequency and damping are specified in spk_args.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L404-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.phase_to_potential-Tuple{Real, Real}" href="#PhasorNetworks.phase_to_potential-Tuple{Real, Real}"><code>PhasorNetworks.phase_to_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_potential(phase::Real, t::Real; offset::Real=0.0f0, spk_args::SpikingArgs)</code></pre><p>Convert a single phase value to a complex potential at a specific time point. This is the core implementation of the phase-to-potential conversion.</p><p><strong>Arguments</strong></p><ul><li><code>phase::Real</code>: Phase value in range [-1, 1]</li><li><code>t::Real</code>: Time point at which to compute the potential</li><li><code>offset::Real=0.0f0</code>: Time offset for phase calculations</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li></ul><p><strong>Returns</strong></p><ul><li>Complex number representing the neuron&#39;s potential at time t</li></ul><p><strong>Details</strong></p><p>The potential is computed as: z(t) = exp(ik * (t - offset - (phase - 1)/2 * period)) where k is the neuron&#39;s complex frequency constant (incorporating both oscillation frequency and leakage/damping).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L452-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.phase_to_time" href="#PhasorNetworks.phase_to_time"><code>PhasorNetworks.phase_to_time</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_time(phases::AbstractArray, period::Real, offset::Real = 0.0f0)</code></pre><p>Convert phases to spike times using a specified oscillation period. This is the core implementation that handles the actual conversion math.</p><p><strong>Arguments</strong></p><ul><li><code>phases::AbstractArray</code>: Array of phases in range [-1, 1]</li><li><code>period::Real</code>: Oscillation period length</li><li><code>offset::Real = 0.0f0</code>: Time offset to add to all spike times</li></ul><p><strong>Returns</strong></p><ul><li>Array of spike times in absolute time units, normalized to be within [0, period)</li></ul><p><strong>Details</strong></p><p>The conversion maps phase φ to time t as: t = (φ/2 + 0.5) * period + offset followed by modulo operation to ensure positive times within one period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L146-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.phase_to_time-Tuple{AbstractArray}" href="#PhasorNetworks.phase_to_time-Tuple{AbstractArray}"><code>PhasorNetworks.phase_to_time</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_time(phases::AbstractArray; offset::Real = 0.0f0, spk_args::SpikingArgs)</code></pre><p>Convert phases to spike times using spiking neuron parameters. Phases are interpreted  as relative positions within a neuron&#39;s oscillation period.</p><p><strong>Arguments</strong></p><ul><li><code>phases::AbstractArray</code>: Array of phases in range [-1, 1]</li><li><code>offset::Real = 0.0f0</code>: Time offset to add to all spike times</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters including oscillation period</li></ul><p><strong>Returns</strong></p><ul><li>Array of spike times in absolute time units</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.phase_to_train-Tuple{AbstractArray}" href="#PhasorNetworks.phase_to_train-Tuple{AbstractArray}"><code>PhasorNetworks.phase_to_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase_to_train(phases::AbstractArray; spk_args::SpikingArgs, repeats::Int = 1, offset::Real = 0.0f0)</code></pre><p>Convert an array of phases to a SpikeTrain object, optionally repeating the spike pattern multiple times.</p><p><strong>Arguments</strong></p><ul><li><code>phases::AbstractArray</code>: Array of phases in range [-1, 1]</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>repeats::Int = 1</code>: Number of times to repeat the spike pattern</li><li><code>offset::Real = 0.0f0</code>: Time offset for the spike train</li></ul><p><strong>Returns</strong></p><ul><li><code>SpikeTrain</code>: Object containing spike times and their corresponding indices</li></ul><p><strong>Details</strong></p><p>For each non-NaN phase value, a spike is generated at the corresponding time. If repeats &gt; 1, the spike pattern is repeated with appropriate time offsets. The spatial structure of the input array is preserved in the SpikeTrain&#39;s shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L220-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.potential_to_phase-Tuple{AbstractArray, Real}" href="#PhasorNetworks.potential_to_phase-Tuple{AbstractArray, Real}"><code>PhasorNetworks.potential_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Convert the potential of a neuron at an arbitrary point in time to its phase relative to a reference</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L480-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.potential_to_phase-Tuple{Tuple{AbstractVector{&lt;:AbstractArray}, AbstractVector}}" href="#PhasorNetworks.potential_to_phase-Tuple{Tuple{AbstractVector{&lt;:AbstractArray}, AbstractVector}}"><code>PhasorNetworks.potential_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">potential_to_phase(ut::Tuple{&lt;:AbstractVector{&lt;:AbstractArray}, &lt;:AbstractVector}; spk_args::SpikingArgs, kwargs...)</code></pre><p>Decodes the phase from a tuple of potentials and times, as produced by an <code>ODESolution</code>. This is a convenience function for handling the output of ODE solvers like <code>(sol.u, sol.t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L509-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.potential_to_time-Tuple{AbstractArray, AbstractVector}" href="#PhasorNetworks.potential_to_time-Tuple{AbstractArray, AbstractVector}"><code>PhasorNetworks.potential_to_time</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">potential_to_time(u::AbstractArray, ts::AbstractVector; spk_args::SpikingArgs, dim::Int=-1)</code></pre><p>Calculate spike times for an array of neuron potentials over multiple time points.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractArray</code>: Array of complex potentials</li><li><code>ts::AbstractVector</code>: Vector of time points</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>dim::Int=-1</code>: Dimension along which time varies (defaults to last dimension)</li></ul><p><strong>Returns</strong></p><ul><li>Array of predicted spike times with same shape as input</li></ul><p><strong>Throws</strong></p><ul><li>AssertionError if size along time dimension doesn&#39;t match length of ts</li></ul><p><strong>Details</strong></p><p>Processes each time slice of the potential array separately, computing spike times for each potential at the corresponding time point. The results are stacked back together along the specified dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L794-L815">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.potential_to_time-Tuple{AbstractArray, Real}" href="#PhasorNetworks.potential_to_time-Tuple{AbstractArray, Real}"><code>PhasorNetworks.potential_to_time</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">potential_to_time(u::AbstractArray, t::Real; spk_args::SpikingArgs)</code></pre><p>Calculate expected spike times for an array of neuron potentials at a given time.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractArray</code>: Array of complex potentials</li><li><code>t::Real</code>: Current time point</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li></ul><p><strong>Returns</strong></p><ul><li>Array of predicted spike times</li></ul><p><strong>Details</strong></p><p>For each complex potential:</p><ol><li>Calculates angle in complex plane</li><li>Determines angular distance to π/2 (spiking threshold)</li><li>Converts this angle to time using neuron frequency</li><li>Adds to current time to get absolute spike time</li><li>Ensures all times are positive by adding period if needed</li></ol><p>The spiking angle π/2 represents the phase at which a neuron generates a spike in the Resonate-and-Fire model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L756-L779">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.realvec_to_cmpx-Tuple{Array{&lt;:Real}}" href="#PhasorNetworks.realvec_to_cmpx-Tuple{Array{&lt;:Real}}"><code>PhasorNetworks.realvec_to_cmpx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">realvec_to_cmpx(u::Array{&lt;:Real})</code></pre><p>Convert a real-valued array with a leading dimension of size 2 back to complex numbers. The first slice along dimension 1 becomes the real part, and the second slice becomes the imaginary part.</p><p><strong>Arguments</strong></p><ul><li><code>u::Array{&lt;:Real}</code>: Input array with shape (2, ...)</li></ul><p><strong>Returns</strong></p><ul><li>Complex array with shape matching input dimensions excluding the first</li></ul><p><strong>Throws</strong></p><ul><li>AssertionError if first dimension is not of size 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L100-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.soft_angle" href="#PhasorNetworks.soft_angle"><code>PhasorNetworks.soft_angle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">soft_angle(x::AbstractArray{&lt;:Complex}, r_lo::Real = 0.1f0, r_hi::Real = 0.2f0)</code></pre><p>Calculate angles of complex numbers with a soft threshold based on magnitude. The output is scaled by a sigmoid function of the magnitude, which smoothly  transitions between 0 and 1 in the range [r<em>lo, r</em>hi].</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray{&lt;:Complex}</code>: Array of complex numbers</li><li><code>r_lo::Real = 0.1f0</code>: Lower threshold for magnitude scaling</li><li><code>r_hi::Real = 0.2f0</code>: Upper threshold for magnitude scaling</li></ul><p><strong>Returns</strong></p><ul><li>Array of angles in units of π radians, scaled by magnitude-dependent sigmoid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L51-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.solution_to_phase-Tuple{SciMLBase.ODESolution}" href="#PhasorNetworks.solution_to_phase-Tuple{SciMLBase.ODESolution}"><code>PhasorNetworks.solution_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solution_to_phase(sol::ODESolution; final_t::Bool=false, offset::Real=0.0f0, 
                 spk_args::SpikingArgs, kwargs...)</code></pre><p>Convert an ODESolution to phases, either at all time points or just the final time.</p><p><strong>Arguments</strong></p><ul><li><code>sol::ODESolution</code>: ODE solution object</li><li><code>final_t::Bool=false</code>: If true, only compute phase at final time point</li><li><code>offset::Real=0.0f0</code>: Time offset for phase calculations</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>kwargs...</code>: Additional arguments passed to potential<em>to</em>phase</li></ul><p><strong>Returns</strong></p><ul><li>If final_t is true: Array of phases at final time point</li><li>If final_t is false: Array of phases at all saved time points</li></ul><p><strong>Details</strong></p><p>Converts the ODE solution to potentials and then to phases. Can either process the entire time series or just the final state, which is useful for different analysis scenarios.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L601-L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.solution_to_phase-Tuple{Union{Function, SciMLBase.ODESolution}, Array}" href="#PhasorNetworks.solution_to_phase-Tuple{Union{Function, SciMLBase.ODESolution}, Array}"><code>PhasorNetworks.solution_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solution_to_phase(sol::Union{ODESolution, Function}, t::Array; offset::Real=0.0f0, 
                 spk_args::SpikingArgs, kwargs...)</code></pre><p>Convert a solution (ODE or function) to phases at specified time points.</p><p><strong>Arguments</strong></p><ul><li><code>sol::Union{ODESolution, Function}</code>: ODE solution object or interpolating function</li><li><code>t::Array</code>: Array of time points at which to compute phases</li><li><code>offset::Real=0.0f0</code>: Time offset for phase calculations</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>kwargs...</code>: Additional arguments passed to potential<em>to</em>phase</li></ul><p><strong>Returns</strong></p><ul><li>Array of phases at the specified time points</li></ul><p><strong>Details</strong></p><p>Evaluates the solution at given time points, converts to potentials, and then computes the corresponding phases. This allows for flexible sampling of the solution&#39;s phase representation at arbitrary time points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L637-L657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.solution_to_potential-Tuple{SciMLBase.ODESolution}" href="#PhasorNetworks.solution_to_potential-Tuple{SciMLBase.ODESolution}"><code>PhasorNetworks.solution_to_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solution_to_potential(ode_sol::ODESolution)</code></pre><p>Convert an ODESolution directly to an array of complex potentials.</p><p><strong>Arguments</strong></p><ul><li><code>ode_sol::ODESolution</code>: ODE solution object</li></ul><p><strong>Returns</strong></p><ul><li>Array of complex potentials sampled at the solution&#39;s saved time points</li></ul><p><strong>Details</strong></p><p>Simple conversion of an ODESolution to an array format, using the solution&#39;s internally saved time points. Useful when you want to work with the exact time points at which the ODE solver saved its results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L581-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.solution_to_potential-Tuple{Union{Function, SciMLBase.ODESolution}, Array}" href="#PhasorNetworks.solution_to_potential-Tuple{Union{Function, SciMLBase.ODESolution}, Array}"><code>PhasorNetworks.solution_to_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solution_to_potential(func_sol::Union{ODESolution, Function}, t::Array)</code></pre><p>Convert a solution function or ODESolution to an array of complex potentials at specified times.</p><p><strong>Arguments</strong></p><ul><li><code>func_sol::Union{ODESolution, Function}</code>: ODE solution object or interpolating function</li><li><code>t::Array</code>: Array of time points at which to evaluate the solution</li></ul><p><strong>Returns</strong></p><ul><li>Array of complex potentials with time as the last dimension</li></ul><p><strong>Details</strong></p><p>Takes a solution (either as a function or ODESolution object) and evaluates it at specified time points, stacking the results along a new final dimension. This is useful for converting continuous solution functions into discretely sampled arrays of potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L555-L572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.solution_to_train-Tuple{AbstractArray{&lt;:Complex}, AbstractVector{&lt;:Real}}" href="#PhasorNetworks.solution_to_train-Tuple{AbstractArray{&lt;:Complex}, AbstractVector{&lt;:Real}}"><code>PhasorNetworks.solution_to_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This implementation takes a single matrix at pre-selected, representative times and converts each temporal slice to spikes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L948-L951">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.solution_to_train-Tuple{AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:Real}, Tuple{Real, Real}}" href="#PhasorNetworks.solution_to_train-Tuple{AbstractVector{&lt;:AbstractArray}, AbstractVector{&lt;:Real}, Tuple{Real, Real}}"><code>PhasorNetworks.solution_to_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This implementation takes a full solution (represented by a vector of arrays) and finds the spikes from it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L933-L935">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.solution_to_train-Tuple{Union{Function, SciMLBase.ODESolution}, Tuple{Real, Real}}" href="#PhasorNetworks.solution_to_train-Tuple{Union{Function, SciMLBase.ODESolution}, Tuple{Real, Real}}"><code>PhasorNetworks.solution_to_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solution_to_train(sol::Union{ODESolution,Function}, tspan::Tuple{&lt;:Real, &lt;:Real}; 
                 spk_args::SpikingArgs, offset::Real)</code></pre><p>Convert a continuous ODE solution or interpolating function to a discrete spike train by sampling at cycle boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>sol::Union{ODESolution,Function}</code>: Either an ODESolution object or a function that can be evaluated at arbitrary time points to get the system state</li><li><code>tspan::Tuple{&lt;:Real, &lt;:Real}</code>: Time span (t<em>start, t</em>end) over which to generate spikes</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>offset::Real</code>: Time offset for spike timing calculations</li></ul><p><strong>Returns</strong></p><ul><li><code>SpikeTrain</code>: Object containing the detected spikes and their timing information</li></ul><p><strong>Details</strong></p><ol><li>Determines cycle boundary times within the specified time span</li><li>Samples the solution at these cycle boundaries</li><li>Converts the sampled potentials to spike times using threshold detection</li></ol><p>This function provides a way to discretize a continuous dynamical solution into a sequence of spikes, which is useful for analyzing the system&#39;s behavior in terms of discrete events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L897-L922">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.time_to_phase-Tuple{AbstractArray, Real, Real}" href="#PhasorNetworks.time_to_phase-Tuple{AbstractArray, Real, Real}"><code>PhasorNetworks.time_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_to_phase(times::AbstractArray, period::Real, offset::Real)</code></pre><p>Convert spike times to phases using a specified oscillation period. This is the inverse operation of phase<em>to</em>time.</p><p><strong>Arguments</strong></p><ul><li><code>times::AbstractArray</code>: Array of spike times</li><li><code>period::Real</code>: Oscillation period length</li><li><code>offset::Real</code>: Time offset to subtract from all spike times</li></ul><p><strong>Returns</strong></p><ul><li>Array of phases in range [-1, 1]</li></ul><p><strong>Details</strong></p><p>The conversion maps time t to phase φ as: φ = 2(((t - offset) mod period)/period - 0.5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L196-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.time_to_phase-Tuple{AbstractArray}" href="#PhasorNetworks.time_to_phase-Tuple{AbstractArray}"><code>PhasorNetworks.time_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_to_phase(times::AbstractArray; spk_args::SpikingArgs, offset::Real)</code></pre><p>Convert spike times to phases using spiking neuron parameters. This is a convenience wrapper that uses the neuron&#39;s period from spk_args.</p><p><strong>Arguments</strong></p><ul><li><code>times::AbstractArray</code>: Array of spike times</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters containing period information</li><li><code>offset::Real</code>: Time offset to subtract from all spike times</li></ul><p><strong>Returns</strong></p><ul><li>Array of phases in range [-1, 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L178-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.time_to_potential-Tuple{AbstractArray, AbstractVector}" href="#PhasorNetworks.time_to_potential-Tuple{AbstractArray, AbstractVector}"><code>PhasorNetworks.time_to_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_to_potential(spikes::AbstractArray, ts::AbstractVector; spk_args::SpikingArgs, dim::Int=-1)</code></pre><p>Calculate complex potentials over multiple time points for neurons with specified spike times.</p><p><strong>Arguments</strong></p><ul><li><code>spikes::AbstractArray</code>: Array of spike times</li><li><code>ts::AbstractVector</code>: Vector of time points at which to compute potentials</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>dim::Int=-1</code>: Dimension along which time varies (defaults to last dimension)</li></ul><p><strong>Returns</strong></p><ul><li>Array of complex potentials with same shape as input</li></ul><p><strong>Throws</strong></p><ul><li>AssertionError if size along time dimension doesn&#39;t match length of ts</li></ul><p><strong>Details</strong></p><p>Processes each time slice of the spike times array separately, computing potentials at each corresponding time point. The results are stacked back together along the specified dimension, maintaining the original array structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L863-L884">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.time_to_potential-Tuple{AbstractArray, Real}" href="#PhasorNetworks.time_to_potential-Tuple{AbstractArray, Real}"><code>PhasorNetworks.time_to_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_to_potential(spikes::AbstractArray, t::Real; spk_args::SpikingArgs)</code></pre><p>Calculate complex potentials at a given time for neurons that spiked at specified times.</p><p><strong>Arguments</strong></p><ul><li><code>spikes::AbstractArray</code>: Array of spike times</li><li><code>t::Real</code>: Time at which to compute the potentials</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li></ul><p><strong>Returns</strong></p><ul><li>Array of complex potentials</li></ul><p><strong>Details</strong></p><p>For each spike time:</p><ol><li>Computes time elapsed since/until spike</li><li>Converts to angular displacement using neuron frequency</li><li>Adjusts relative to spiking angle (π/2)</li><li>Converts to complex potential on unit circle</li></ol><p>The resulting potentials represent the state each neuron would have at time t, given their spike times, assuming ideal oscillatory behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L828-L850">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.train_to_phase-Tuple{SpikeTrainGPU}" href="#PhasorNetworks.train_to_phase-Tuple{SpikeTrainGPU}"><code>PhasorNetworks.train_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">train_to_phase(train::SpikeTrainGPU; spk_args::SpikingArgs)</code></pre><p>Convert a GPU-based spike train to phases. The output remains on the GPU.</p><p><strong>Arguments</strong></p><ul><li><code>train::SpikeTrainGPU</code>: GPU-based spike train</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li></ul><p><strong>Returns</strong></p><ul><li>GPU array of phases in range [-1, 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L271-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.train_to_phase-Tuple{SpikeTrain}" href="#PhasorNetworks.train_to_phase-Tuple{SpikeTrain}"><code>PhasorNetworks.train_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">train_to_phase(train::SpikeTrain; spk_args::SpikingArgs, offset::Real = 0.0f0)</code></pre><p>Convert a spike train to a sequence of phase snapshots, one for each oscillation cycle. For each cycle, creates a phase array matching the original spatial dimensions, with  NaN values for neurons that did not spike in that cycle.</p><p><strong>Arguments</strong></p><ul><li><code>train::SpikeTrain</code>: The spike train to convert</li><li><code>spk_args::SpikingArgs</code>: Spiking neuron parameters</li><li><code>offset::Real = 0.0f0</code>: Additional time offset for phase calculation</li></ul><p><strong>Returns</strong></p><ul><li>Array of phases with shape (original<em>shape..., n</em>cycles), where n_cycles is determined by the temporal span of the spike train. Each slice along the last dimension represents the phases in one oscillation cycle.</li><li>Returns <code>missing</code> if the spike train is empty</li></ul><p><strong>Throws</strong></p><ul><li>AssertionError if any spike times are negative</li></ul><p><strong>Details</strong></p><ol><li>Converts each spike time to a phase within its cycle</li><li>Determines which cycle each spike belongs to</li><li>Creates a phase array for each cycle, filling with NaN by default</li><li>Places each spike&#39;s phase in the appropriate cycle and spatial location</li><li>Stacks all cycles into a single array along a new final dimension</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L290-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhasorNetworks.train_to_phase-Tuple{SpikingCall}" href="#PhasorNetworks.train_to_phase-Tuple{SpikingCall}"><code>PhasorNetworks.train_to_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">train_to_phase(call::SpikingCall)</code></pre><p>Convert a SpikingCall&#39;s spike train to phases using its own spiking parameters.</p><p><strong>Arguments</strong></p><ul><li><code>call::SpikingCall</code>: Contains a spike train and associated spiking parameters</li></ul><p><strong>Returns</strong></p><ul><li>Array of phases in range [-1, 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wilkieolin/PhasorNetworks.jl/blob/0f41c61d7b04b24eac6517cd1ebe12308e7830e2/src/domains.jl#L256-L266">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spiking/">« Spiking</a><a class="docs-footer-nextpage" href="../vsa/">VSA »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 19:51">Wednesday 12 November 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
